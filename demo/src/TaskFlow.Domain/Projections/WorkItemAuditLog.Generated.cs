using ErikLieben.FA.ES;
using ErikLieben.FA.ES.Documents;
using ErikLieben.FA.ES.Projections;
using ErikLieben.FA.ES.VersionTokenParts;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using TaskFlow.Domain.Events.WorkItem;

namespace TaskFlow.Domain.Projections;

// <auto-generated />
[GeneratedCode("ErikLieben.FA.ES", "1.0.0.0")]
[ExcludeFromCodeCoverage]
public partial class WorkItemAuditLog : IWorkItemAuditLog
{

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0.0")]
    [ExcludeFromCodeCoverage]
    public WorkItemAuditLog() : base()
    {
    }

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0.0")]
    [ExcludeFromCodeCoverage]
    public WorkItemAuditLog(IObjectDocumentFactory documentFactory, IEventStreamFactory eventStreamFactory)
      : base(documentFactory, eventStreamFactory)
    {
    }

#nullable enable
    /// <summary>
    /// Applies an event to the projection by dispatching to the appropriate When method using version token.
    /// This is the primary implementation that avoids redundant document lookups.
    /// </summary>
    /// <typeparam name="T">The type of additional data passed through the execution context.</typeparam>
    /// <param name="event">The event to apply to the projection.</param>
    /// <param name="versionToken">The version token associated with the event.</param>
    /// <param name="data">Optional data to pass through the execution context.</param>
    /// <param name="parentContext">Optional parent execution context for nested projections.</param>
    /// <returns>A task representing the asynchronous fold operation.</returns>
    public override Task Fold<T>(IEvent @event, VersionToken versionToken, T? data = default(T?), IExecutionContext? parentContext = null) where T : class
    {

        switch (@event.EventType)
        {
            case "WorkItem.Planned":
                When(JsonEvent.ToEvent(@event, WorkItemPlannedJsonSerializerContext.Default.WorkItemPlanned).Data(), GetWhenParameterValue<String, WorkItemPlanned>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.ResponsibilityAssigned":
                When(JsonEvent.ToEvent(@event, ResponsibilityAssignedJsonSerializerContext.Default.ResponsibilityAssigned).Data(), GetWhenParameterValue<String, ResponsibilityAssigned>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.ResponsibilityRelinquished":
                When(JsonEvent.ToEvent(@event, ResponsibilityRelinquishedJsonSerializerContext.Default.ResponsibilityRelinquished).Data(), GetWhenParameterValue<String, ResponsibilityRelinquished>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.WorkCommenced":
                When(JsonEvent.ToEvent(@event, WorkCommencedJsonSerializerContext.Default.WorkCommenced).Data(), GetWhenParameterValue<String, WorkCommenced>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.WorkCompleted":
                When(JsonEvent.ToEvent(@event, WorkCompletedJsonSerializerContext.Default.WorkCompleted).Data(), GetWhenParameterValue<String, WorkCompleted>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.Reprioritized":
                When(JsonEvent.ToEvent(@event, WorkItemReprioritizedJsonSerializerContext.Default.WorkItemReprioritized).Data(), GetWhenParameterValue<String, WorkItemReprioritized>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.DeadlineEstablished":
                When(JsonEvent.ToEvent(@event, DeadlineEstablishedJsonSerializerContext.Default.DeadlineEstablished).Data(), GetWhenParameterValue<String, DeadlineEstablished>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.DeadlineRemoved":
                When(JsonEvent.ToEvent(@event, DeadlineRemovedJsonSerializerContext.Default.DeadlineRemoved).Data(), GetWhenParameterValue<String, DeadlineRemoved>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.MovedBackFromCompletedToInProgress":
                When(JsonEvent.ToEvent(@event, MovedBackFromCompletedToInProgressJsonSerializerContext.Default.MovedBackFromCompletedToInProgress).Data(), GetWhenParameterValue<String, MovedBackFromCompletedToInProgress>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.MovedBackFromCompletedToPlanned":
                When(JsonEvent.ToEvent(@event, MovedBackFromCompletedToPlannedJsonSerializerContext.Default.MovedBackFromCompletedToPlanned).Data(), GetWhenParameterValue<String, MovedBackFromCompletedToPlanned>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.MovedBackFromInProgressToPlanned":
                When(JsonEvent.ToEvent(@event, MovedBackFromInProgressToPlannedJsonSerializerContext.Default.MovedBackFromInProgressToPlanned).Data(), GetWhenParameterValue<String, MovedBackFromInProgressToPlanned>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.Revived":
                When(JsonEvent.ToEvent(@event, WorkItemRevivedJsonSerializerContext.Default.WorkItemRevived).Data(), GetWhenParameterValue<String, WorkItemRevived>(
                         "String",
                         versionToken, @event)!);
                break;
            case "WorkItem.FeedbackProvided":
                When(JsonEvent.ToEvent(@event, FeedbackProvidedJsonSerializerContext.Default.FeedbackProvided).Data(), GetWhenParameterValue<String, FeedbackProvided>(
                         "String",
                         versionToken, @event)!);
                break;
        }

        return Task.CompletedTask;
    }

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0.0")]
    [ExcludeFromCodeCoverage]
    protected override Task PostWhenAll(IObjectDocument document) { return Task.CompletedTask; }
#nullable restore

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0.0")]
    [ExcludeFromCodeCoverage]
    protected override Dictionary<string, IProjectionWhenParameterValueFactory> WhenParameterValueFactories { get; } =
          new Dictionary<string, IProjectionWhenParameterValueFactory>(){
              {"String", new TaskFlow.Domain.Projections.ObjectIdWhenValueFactory()}
          };

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0.0")]
    [ExcludeFromCodeCoverage]
    public static WorkItemAuditLog? LoadFromJson(string json, IObjectDocumentFactory documentFactory, IEventStreamFactory eventStreamFactory)
    {
        // Deserialize each property manually to preserve data
        System.Int32? pendingDocumentCount = null;
        System.String? checkpointFingerprint = null;
        ErikLieben.FA.ES.Projections.ProjectionStatus? status = null;
        System.Nullable<System.DateTimeOffset> statusChangedAt = null;
        ErikLieben.FA.ES.Projections.RebuildInfo? rebuildInfo = null;
        System.Int32? schemaVersion = null;
        System.Int32? codeSchemaVersion = null;
        System.Boolean? needsSchemaUpgrade = null;
        Checkpoint checkpoint = [];

        var reader = new Utf8JsonReader(System.Text.Encoding.UTF8.GetBytes(json));

        if (!reader.Read() || reader.TokenType != JsonTokenType.StartObject)
            return null;

        while (reader.Read())
        {
            if (reader.TokenType == JsonTokenType.EndObject)
                break;

            if (reader.TokenType != JsonTokenType.PropertyName)
                continue;

            string? propertyName = reader.GetString();
            reader.Read();

            switch (propertyName)
            {
                case "PendingDocumentCount":
                    pendingDocumentCount = JsonSerializer.Deserialize<System.Int32>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
                case "$checkpoint":
                    checkpoint = JsonSerializer.Deserialize<ErikLieben.FA.ES.Checkpoint>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options) ?? [];
                    break;
                case "$checkpointFingerprint":
                    checkpointFingerprint = JsonSerializer.Deserialize<System.String>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
                case "Status":
                    status = JsonSerializer.Deserialize<ErikLieben.FA.ES.Projections.ProjectionStatus>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
                case "StatusChangedAt":
                    statusChangedAt = JsonSerializer.Deserialize<System.Nullable<System.DateTimeOffset>>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
                case "RebuildInfo":
                    rebuildInfo = JsonSerializer.Deserialize<ErikLieben.FA.ES.Projections.RebuildInfo>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
                case "SchemaVersion":
                    schemaVersion = JsonSerializer.Deserialize<System.Int32>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
                case "CodeSchemaVersion":
                    codeSchemaVersion = JsonSerializer.Deserialize<System.Int32>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
                case "NeedsSchemaUpgrade":
                    needsSchemaUpgrade = JsonSerializer.Deserialize<System.Boolean>(ref reader, WorkItemAuditLogJsonSerializerContext.Default.Options);
                    break;
            }
        }

        // Create instance with factories and deserialized properties
        var instance = new WorkItemAuditLog();

        instance.Checkpoint = checkpoint;
        instance.CheckpointFingerprint = checkpointFingerprint;

        return instance;
    }

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0.0")]
    [ExcludeFromCodeCoverage]
    public override string ToJson()
    {
        return JsonSerializer.Serialize(this, WorkItemAuditLogJsonSerializerContext.Default.WorkItemAuditLog);
    }

    /// <summary>
    /// Gets or sets the checkpoint tracking the last processed event position.
    /// </summary>
    [JsonPropertyName("$checkpoint")]
    public override Checkpoint Checkpoint { get; set; } = [];

    /// <summary>
    /// Gets the schema version defined in code via [ProjectionVersion] attribute.
    /// </summary>
    [JsonIgnore]
    public override int CodeSchemaVersion => 1;
}

#nullable enable
// <auto-generated />
/// <summary>
/// Interface defining the public state properties of WorkItemAuditLog.
/// </summary>
public interface IWorkItemAuditLog
{
    public Int32 PendingDocumentCount { get; }
    public String? CheckpointFingerprint { get; }
    public ProjectionStatus Status { get; }
    public Nullable<System.DateTimeOffset> StatusChangedAt { get; }
    public RebuildInfo? RebuildInfo { get; }
    public Int32 SchemaVersion { get; }
    public Int32 CodeSchemaVersion { get; }
    public Boolean NeedsSchemaUpgrade { get; }
}
#nullable restore

[JsonSerializable(typeof(WorkItemPlanned))]
[JsonSerializable(typeof(ResponsibilityAssigned))]
[JsonSerializable(typeof(ResponsibilityRelinquished))]
[JsonSerializable(typeof(WorkCommenced))]
[JsonSerializable(typeof(WorkCompleted))]
[JsonSerializable(typeof(WorkItemReprioritized))]
[JsonSerializable(typeof(DeadlineEstablished))]
[JsonSerializable(typeof(DeadlineRemoved))]
[JsonSerializable(typeof(MovedBackFromCompletedToInProgress))]
[JsonSerializable(typeof(MovedBackFromCompletedToPlanned))]
[JsonSerializable(typeof(MovedBackFromInProgressToPlanned))]
[JsonSerializable(typeof(WorkItemRevived))]
[JsonSerializable(typeof(FeedbackProvided))]
[JsonSerializable(typeof(System.Int32))]
[JsonSerializable(typeof(ErikLieben.FA.ES.Checkpoint))]
[JsonSerializable(typeof(System.Collections.Generic.Dictionary<System.String, ErikLieben.FA.ES.Projections.IProjectionWhenParameterValueFactory>))]
[JsonSerializable(typeof(ErikLieben.FA.ES.Projections.IProjectionWhenParameterValueFactory))]
[JsonSerializable(typeof(ErikLieben.FA.ES.Projections.ProjectionStatus))]
[JsonSerializable(typeof(System.Enum))]
[JsonSerializable(typeof(System.Nullable<System.DateTimeOffset>))]
[JsonSerializable(typeof(System.DateTimeOffset))]
[JsonSerializable(typeof(System.DayOfWeek))]
[JsonSerializable(typeof(System.TimeSpan))]
[JsonSerializable(typeof(System.Double))]
[JsonSerializable(typeof(ErikLieben.FA.ES.Projections.RebuildInfo))]
[JsonSerializable(typeof(ErikLieben.FA.ES.Projections.RebuildStrategy))]
[JsonSerializable(typeof(System.Boolean))]
[JsonSerializable(typeof(WorkItemAuditLog))]
// <auto-generated />
/// <summary>
/// JSON serializer context for WorkItemAuditLog types.
/// </summary>
internal partial class WorkItemAuditLogJsonSerializerContext : JsonSerializerContext
{
}

