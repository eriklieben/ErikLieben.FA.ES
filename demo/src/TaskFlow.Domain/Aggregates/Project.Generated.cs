using ErikLieben.FA.ES;
using ErikLieben.FA.ES.Aggregates;
using ErikLieben.FA.ES.Documents;
using ErikLieben.FA.ES.EventStream;
using ErikLieben.FA.ES.Processors;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using TaskFlow.Domain.Events.Project;
using TaskFlow.Domain.Upcast;
using TaskFlow.Domain.ValueObjects;
using TaskFlow.Domain.ValueObjects.Project;

#nullable enable

namespace TaskFlow.Domain.Aggregates;

// <auto-generated />
/// <summary>
/// Project aggregate root implementing event sourcing patterns.
/// </summary>
[GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
[ExcludeFromCodeCoverage]
public partial class Project : Aggregate, IBase, IProject
{

    /// <summary>
    /// Gets the logical object name for this aggregate type (AOT-friendly static member).
    /// </summary>
    public static string ObjectName => "project";

    /// <summary>
    /// Creates a new instance of the aggregate from an event stream (AOT-friendly factory).
    /// </summary>
    /// <param name="stream">The event stream for the aggregate.</param>
    /// <returns>A new instance of the aggregate.</returns>
    public static Project Create(IEventStream stream) => new Project(stream);

    /// <summary>
    /// Applies an event to the aggregate state by dispatching to the appropriate When method.
    /// </summary>
    /// <param name="event">The event to apply to the aggregate.</param>
    public override void Fold(IEvent @event)
    {
        switch (@event.EventType)
        {
            case "Project.Initiated":
                When(JsonEvent.To(@event, ProjectInitiatedJsonSerializerContext.Default.ProjectInitiated));
                break;
            case "Project.Rebranded":
                When(JsonEvent.To(@event, ProjectRebrandedJsonSerializerContext.Default.ProjectRebranded));
                break;
            case "Project.ScopeRefined":
                When(JsonEvent.To(@event, ProjectScopeRefinedJsonSerializerContext.Default.ProjectScopeRefined));
                break;
            case "Project.LanguagesConfigured":
                When(JsonEvent.To(@event, ProjectLanguagesConfiguredJsonSerializerContext.Default.ProjectLanguagesConfigured));
                break;
            case "Project.MemberJoined":
                if (@event.SchemaVersion == 1)
                    When(JsonEvent.To(@event, MemberJoinedProjectV1JsonSerializerContext.Default.MemberJoinedProjectV1));
                else
                    When(JsonEvent.To(@event, MemberJoinedProjectJsonSerializerContext.Default.MemberJoinedProject));
                break;
            case "Project.MemberLeft":
                When(JsonEvent.To(@event, MemberLeftProjectJsonSerializerContext.Default.MemberLeftProject));
                break;
            case "Project.WorkItemAddedToProject":
                When(JsonEvent.To(@event, WorkItemAddedToProjectJsonSerializerContext.Default.WorkItemAddedToProject));
                break;
            case "Project.WorkItemStatusChangedInProject":
                When(JsonEvent.To(@event, WorkItemStatusChangedInProjectJsonSerializerContext.Default.WorkItemStatusChangedInProject));
                break;
            case "Project.WorkItemReordered":
                When(JsonEvent.To(@event, WorkItemReorderedJsonSerializerContext.Default.WorkItemReordered));
                break;
            case "Project.Completed":
                WhenProjectCompleted();
                break;
            case "Project.CompletedSuccessfully":
                WhenProjectCompletedSuccessfully();
                break;
            case "Project.Cancelled":
                WhenProjectCancelled();
                break;
            case "Project.Failed":
                WhenProjectFailed();
                break;
            case "Project.Delivered":
                WhenProjectDelivered();
                break;
            case "Project.Suspended":
                WhenProjectSuspended();
                break;
            case "Project.Merged":
                WhenProjectMerged();
                break;
            case "Project.Reactivated":
                WhenProjectReactivated();
                break;
            case "Project.DemoNoteAdded":
                WhenDemoNoteAdded();
                break;
        }

        PostWhen(Stream.Document, @event);
    }

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
    [ExcludeFromCodeCoverage]
    protected override void GeneratedSetup()
    {
        Stream.RegisterEvent<ProjectInitiated>(
      "Project.Initiated",
      ProjectInitiatedJsonSerializerContext.Default.ProjectInitiated);
        Stream.RegisterEvent<ProjectRebranded>(
            "Project.Rebranded",
            ProjectRebrandedJsonSerializerContext.Default.ProjectRebranded);
        Stream.RegisterEvent<ProjectScopeRefined>(
            "Project.ScopeRefined",
            ProjectScopeRefinedJsonSerializerContext.Default.ProjectScopeRefined);
        Stream.RegisterEvent<ProjectLanguagesConfigured>(
            "Project.LanguagesConfigured",
            ProjectLanguagesConfiguredJsonSerializerContext.Default.ProjectLanguagesConfigured);
        Stream.RegisterEvent<MemberJoinedProjectV1>(
            "Project.MemberJoined",
            MemberJoinedProjectV1JsonSerializerContext.Default.MemberJoinedProjectV1);
        Stream.RegisterEvent<MemberJoinedProject>(
            "Project.MemberJoined",
            2,
            MemberJoinedProjectJsonSerializerContext.Default.MemberJoinedProject);
        Stream.RegisterEvent<MemberLeftProject>(
            "Project.MemberLeft",
            MemberLeftProjectJsonSerializerContext.Default.MemberLeftProject);
        Stream.RegisterEvent<WorkItemAddedToProject>(
            "Project.WorkItemAddedToProject",
            WorkItemAddedToProjectJsonSerializerContext.Default.WorkItemAddedToProject);
        Stream.RegisterEvent<WorkItemStatusChangedInProject>(
            "Project.WorkItemStatusChangedInProject",
            WorkItemStatusChangedInProjectJsonSerializerContext.Default.WorkItemStatusChangedInProject);
        Stream.RegisterEvent<WorkItemReordered>(
            "Project.WorkItemReordered",
            WorkItemReorderedJsonSerializerContext.Default.WorkItemReordered);
        Stream.RegisterEvent<ProjectCompleted>(
            "Project.Completed",
            ProjectCompletedJsonSerializerContext.Default.ProjectCompleted);
        Stream.RegisterEvent<ProjectCompletedSuccessfully>(
            "Project.CompletedSuccessfully",
            ProjectCompletedSuccessfullyJsonSerializerContext.Default.ProjectCompletedSuccessfully);
        Stream.RegisterEvent<ProjectCancelled>(
            "Project.Cancelled",
            ProjectCancelledJsonSerializerContext.Default.ProjectCancelled);
        Stream.RegisterEvent<ProjectFailed>(
            "Project.Failed",
            ProjectFailedJsonSerializerContext.Default.ProjectFailed);
        Stream.RegisterEvent<ProjectDelivered>(
            "Project.Delivered",
            ProjectDeliveredJsonSerializerContext.Default.ProjectDelivered);
        Stream.RegisterEvent<ProjectSuspended>(
            "Project.Suspended",
            ProjectSuspendedJsonSerializerContext.Default.ProjectSuspended);
        Stream.RegisterEvent<ProjectMerged>(
            "Project.Merged",
            ProjectMergedJsonSerializerContext.Default.ProjectMerged);
        Stream.RegisterEvent<ProjectReactivated>(
            "Project.Reactivated",
            ProjectReactivatedJsonSerializerContext.Default.ProjectReactivated);
        Stream.RegisterEvent<DemoNoteAdded>(
            "Project.DemoNoteAdded",
            DemoNoteAddedJsonSerializerContext.Default.DemoNoteAdded);
        Stream.RegisterUpcast(new ProjectCompletedUpcast());
        Stream.SetSnapShotType(ProjectJsonSerializerContext.Default.ProjectSnapshot);
        Stream.SetAggregateType(ProjectJsonSerializerContext.Default.Project);

        // Freeze the EventTypeRegistry for optimized lookups (~50% faster)
        Stream.EventTypeRegistry.Freeze();
    }

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
    [ExcludeFromCodeCoverage]
    public override void ProcessSnapshot(object snapshot)
    {
        throw new NotImplementedException();
    }
}

// <auto-generated />
/// <summary>
/// Interface defining the public state properties of Project.
/// </summary>
public interface IProject
{
    public EventTypeRegistry? EventTypeRegistry { get; }
    public String? Name { get; }
    public String? Description { get; }
    public UserProfileId? OwnerId { get; }
    public Boolean IsCompleted { get; }
    public ProjectOutcome Outcome { get; }
    public Dictionary<TaskFlow.Domain.ValueObjects.UserProfileId, System.String>? TeamMembers { get; }
    public List<System.String>? RequiredLanguages { get; }
    public List<TaskFlow.Domain.ValueObjects.WorkItemId>? PlannedItemsOrder { get; }
    public List<TaskFlow.Domain.ValueObjects.WorkItemId>? InProgressItemsOrder { get; }
    public List<TaskFlow.Domain.ValueObjects.WorkItemId>? CompletedItemsOrder { get; }
    public ObjectMetadata<TaskFlow.Domain.ValueObjects.ProjectId>? Metadata { get; }
}

// <auto-generated />
/// <summary>
/// Snapshot record for persisting Project aggregate state.
/// </summary>
[GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
[ExcludeFromCodeCoverage]
public record ProjectSnapshot : IProject
{
    public required EventTypeRegistry? EventTypeRegistry { get; init; }
    public required String? Name { get; init; }
    public required String? Description { get; init; }
    public required UserProfileId? OwnerId { get; init; }
    public required Boolean IsCompleted { get; init; }
    public required ProjectOutcome Outcome { get; init; }
    public required Dictionary<TaskFlow.Domain.ValueObjects.UserProfileId, System.String>? TeamMembers { get; init; }
    public required List<System.String>? RequiredLanguages { get; init; }
    public required List<TaskFlow.Domain.ValueObjects.WorkItemId>? PlannedItemsOrder { get; init; }
    public required List<TaskFlow.Domain.ValueObjects.WorkItemId>? InProgressItemsOrder { get; init; }
    public required List<TaskFlow.Domain.ValueObjects.WorkItemId>? CompletedItemsOrder { get; init; }
    public required ObjectMetadata<TaskFlow.Domain.ValueObjects.ProjectId>? Metadata { get; init; }
}

[JsonSerializable(typeof(ProjectInitiated))]
[JsonSerializable(typeof(ProjectRebranded))]
[JsonSerializable(typeof(ProjectScopeRefined))]
[JsonSerializable(typeof(ProjectLanguagesConfigured))]
[JsonSerializable(typeof(MemberJoinedProjectV1))]
[JsonSerializable(typeof(MemberJoinedProject))]
[JsonSerializable(typeof(MemberLeftProject))]
[JsonSerializable(typeof(WorkItemAddedToProject))]
[JsonSerializable(typeof(WorkItemStatusChangedInProject))]
[JsonSerializable(typeof(WorkItemReordered))]
[JsonSerializable(typeof(ProjectCompleted))]
[JsonSerializable(typeof(ProjectCompletedSuccessfully))]
[JsonSerializable(typeof(ProjectCancelled))]
[JsonSerializable(typeof(ProjectFailed))]
[JsonSerializable(typeof(ProjectDelivered))]
[JsonSerializable(typeof(ProjectSuspended))]
[JsonSerializable(typeof(ProjectMerged))]
[JsonSerializable(typeof(ProjectReactivated))]
[JsonSerializable(typeof(DemoNoteAdded))]
[JsonSerializable(typeof(ProjectSnapshot))]
[JsonSerializable(typeof(Project))]
[JsonSerializable(typeof(ProjectId))]
[JsonSerializable(typeof(ErikLieben.FA.ES.EventStream.EventTypeInfo))]
[JsonSerializable(typeof(ErikLieben.FA.StronglyTypedIds.StronglyTypedId<String>))]
[JsonSerializable(typeof(System.Action<Object, Object>))]
[JsonSerializable(typeof(System.Action<Object>))]
[JsonSerializable(typeof(System.Boolean))]
[JsonSerializable(typeof(System.Char))]
[JsonSerializable(typeof(System.Enum))]
[JsonSerializable(typeof(System.Func<Object, Object, Boolean>))]
[JsonSerializable(typeof(System.Func<Object, Object>))]
[JsonSerializable(typeof(System.Func<Object>))]
[JsonSerializable(typeof(System.Guid))]
[JsonSerializable(typeof(System.MulticastDelegate))]
[JsonSerializable(typeof(System.Object))]
[JsonSerializable(typeof(System.String))]
[JsonSerializable(typeof(System.Text.Encodings.Web.JavaScriptEncoder))]
[JsonSerializable(typeof(System.Text.Encodings.Web.TextEncoder))]
[JsonSerializable(typeof(System.Text.Json.JsonCommentHandling))]
[JsonSerializable(typeof(System.Text.Json.JsonNamingPolicy))]
[JsonSerializable(typeof(System.Text.Json.JsonSerializerOptions))]
[JsonSerializable(typeof(System.Text.Json.Serialization.JsonConverter))]
[JsonSerializable(typeof(System.Text.Json.Serialization.JsonIgnoreCondition))]
[JsonSerializable(typeof(System.Text.Json.Serialization.JsonNumberHandling))]
[JsonSerializable(typeof(System.Text.Json.Serialization.JsonObjectCreationHandling))]
[JsonSerializable(typeof(System.Text.Json.Serialization.JsonUnknownDerivedTypeHandling))]
[JsonSerializable(typeof(System.Text.Json.Serialization.JsonUnknownTypeHandling))]
[JsonSerializable(typeof(System.Text.Json.Serialization.JsonUnmappedMemberHandling))]
[JsonSerializable(typeof(System.Text.Json.Serialization.Metadata.JsonDerivedType))]
[JsonSerializable(typeof(System.Text.Json.Serialization.Metadata.JsonParameterInfo))]
[JsonSerializable(typeof(System.Text.Json.Serialization.Metadata.JsonPolymorphismOptions))]
[JsonSerializable(typeof(System.Text.Json.Serialization.Metadata.JsonPropertyInfo))]
[JsonSerializable(typeof(System.Text.Json.Serialization.Metadata.JsonTypeInfo))]
[JsonSerializable(typeof(System.Text.Json.Serialization.Metadata.JsonTypeInfoKind))]
[JsonSerializable(typeof(System.Text.Json.Serialization.ReferenceHandler))]
[JsonSerializable(typeof(System.Type))]
[JsonSerializable(typeof(TaskFlow.Domain.ValueObjects.ProjectId))]
// <auto-generated />
/// <summary>
/// JSON serializer context for Project types.
/// </summary>
internal partial class ProjectJsonSerializerContext : JsonSerializerContext
{
}

//<auto-generated />
/// <summary>
/// Factory interface for creating Project aggregate instances.
/// </summary>
public partial interface IProjectFactory : IAggregateFactory<Project, ProjectId>
{
}

//<auto-generated />
/// <summary>
/// Factory for creating and loading Project aggregate instances from documents and event streams.
/// </summary>
[GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
[ExcludeFromCodeCoverage]
public partial class ProjectFactory : IProjectFactory
{
    private readonly IEventStreamFactory eventStreamFactory;
    private readonly IObjectDocumentFactory objectDocumentFactory;
    private readonly IServiceProvider serviceProvider;

    /// <summary>
    /// Gets the object name used for document storage.
    /// </summary>
    public static string ObjectName => "project";

    /// <summary>
    /// Gets the object name used for document storage.
    /// </summary>
    /// <returns>The object name.</returns>
    public string GetObjectName()
    {
        return ObjectName;
    }

    /// <summary>
    /// Initializes a new instance of the ProjectFactory class.
    /// </summary>
    /// <param name="serviceProvider">Service provider for dependency injection.</param>
    /// <param name="eventStreamFactory">Factory for creating event streams.</param>
    /// <param name="objectDocumentFactory">Factory for creating and managing object documents.</param>
    public ProjectFactory(
      IServiceProvider serviceProvider,
      IEventStreamFactory eventStreamFactory,
      IObjectDocumentFactory objectDocumentFactory)
    {
        ArgumentNullException.ThrowIfNull(serviceProvider);
        ArgumentNullException.ThrowIfNull(eventStreamFactory);
        ArgumentNullException.ThrowIfNull(objectDocumentFactory);

        this.serviceProvider = serviceProvider;
        this.eventStreamFactory = eventStreamFactory;
        this.objectDocumentFactory = objectDocumentFactory;
    }

    /// <summary>
    /// Creates a Project instance from an event stream.
    /// </summary>
    /// <param name="eventStream">The event stream to create the aggregate from.</param>
    /// <returns>A new Project instance.</returns>
    public Project Create(IEventStream eventStream)
    {
        ArgumentNullException.ThrowIfNull(eventStream);

        // get the params required from DI

        return new Project(eventStream);
    }

    /// <summary>
    /// Creates a Project instance from an object document.
    /// </summary>
    /// <param name="document">The object document to create the aggregate from.</param>
    /// <returns>A new Project instance.</returns>
    public Project Create(IObjectDocument document)
    {
        ArgumentNullException.ThrowIfNull(document);

        // get the params required from DI

        var eventStream = eventStreamFactory.Create(document);
        return new Project(eventStream);
    }

    /// <summary>
    /// Creates a new Project aggregate with the specified identifier.
    /// </summary>
    /// <param name="id">The identifier for the new aggregate.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>A new Project instance.</returns>
    public async Task<Project> CreateAsync(ProjectId id, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetOrCreateAsync(ObjectName, id.ToString(), null, null);

        var obj = Create(document);
        await obj.Fold();
        return obj;
    }

    /// <summary>
    /// Creates a new Project aggregate with the specified identifier and first event.
    /// </summary>
    /// <typeparam name="T">The type of the first event.</typeparam>
    /// <param name="id">The identifier for the new aggregate.</param>
    /// <param name="firstEvent">The first event to append to the aggregate's event stream.</param>
    /// <param name="metadata">Optional metadata to attach to the event.</param>
    /// <returns>A new Project instance with the event applied.</returns>
    protected async Task<Project> CreateAsync<T>(ProjectId id, T firstEvent, ActionMetadata? metadata = null) where T : class
    {
        var document = await this.objectDocumentFactory.GetOrCreateAsync(ObjectName, id.ToString(), null, null);

        var eventStream = eventStreamFactory.Create(document);
        var obj = new Project(eventStream);
        await eventStream.Session(context => context.Append(firstEvent, metadata));
        await obj.Fold();
        return obj;
    }

    /// <summary>
    /// Gets an existing Project aggregate by identifier.
    /// </summary>
    /// <param name="id">The identifier of the aggregate to retrieve.</param>
    /// <param name="upToVersion">Optional maximum event version to fold. If null, loads to current state.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>The loaded Project instance.</returns>
    [Obsolete("Use IProjectRepository.GetByIdAsync instead. This method will be removed in a future version.")]
    public async Task<Project> GetAsync(ProjectId id, int? upToVersion = null, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetAsync(ObjectName, id.ToString(), null, null);

        // Create event stream
        var eventStream = eventStreamFactory.Create(document);

        // Create aggregate FIRST to register upcasters and event handlers
        var obj = new Project(eventStream);

        // Read events up to version WITH upcasting applied
        var events = await eventStream.ReadAsync(0, upToVersion);

        // Fold events into the aggregate
        foreach (var e in events)
        {
            obj.Fold(e);
        }

        return obj;
    }

    /// <summary>
    /// Gets an existing Project aggregate by identifier along with its document.
    /// </summary>
    /// <param name="id">The identifier of the aggregate to retrieve.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>A tuple containing the loaded Project instance and its document.</returns>
    [Obsolete("Use IProjectRepository.GetByIdWithDocumentAsync instead. This method will be removed in a future version.")]
    public async Task<(Project, IObjectDocument)> GetWithDocumentAsync(ProjectId id, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetAsync(ObjectName, id.ToString(), null, null);
        var obj = Create(document);
        await obj.Fold();
        return (obj, document);
    }

    /// <summary>
    /// Gets the first Project aggregate with the specified document tag.
    /// </summary>
    /// <param name="tag">The document tag to search for.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>The first matching Project instance, or null if not found.</returns>
    [Obsolete("Use IProjectRepository.GetFirstByDocumentTagAsync instead. This method will be removed in a future version.")]
    public async Task<Project?> GetFirstByDocumentTag(string tag, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetFirstByObjectDocumentTag(ObjectName, tag);
        if (document == null)
        {
            return null;
        }
        var obj = Create(document);
        await obj.Fold();
        return obj;
    }

    /// <summary>
    /// Gets all Project aggregates with the specified document tag.
    /// </summary>
    /// <param name="tag">The document tag to search for.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>A collection of all matching Project instances.</returns>
    [Obsolete("Use IProjectRepository.GetAllByDocumentTagAsync instead. This method will be removed in a future version.")]
    public async Task<IEnumerable<Project>> GetAllByDocumentTag(string tag, CancellationToken cancellationToken = default)
    {
        var documents = (await this.objectDocumentFactory.GetByObjectDocumentTag(ObjectName, tag));
        var items = new List<Project>();
        foreach (var document in documents)
        {
            var obj = Create(document);
            await obj.Fold();
            items.Add(obj);
        }
        return items;
    }
}

//<auto-generated />
public partial interface IProjectRepository
{
    /// <summary>
    /// Gets a paginated list of all Project object IDs using continuation tokens.
    /// </summary>
    Task<PagedResult<string>> GetObjectIdsAsync(
        string? continuationToken = null,
        int pageSize = 100,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a single aggregate by ID.
    /// </summary>
    /// <param name="upToVersion">Optional: The maximum event version to fold. If null, loads to current state.</param>
    Task<Project?> GetByIdAsync(
        ProjectId id,
        int? upToVersion = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a single aggregate by ID along with its document.
    /// </summary>
    Task<(Project?, IObjectDocument?)> GetByIdWithDocumentAsync(
        ProjectId id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the first aggregate with the specified document tag.
    /// </summary>
    Task<Project?> GetFirstByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all aggregates with the specified document tag.
    /// </summary>
    Task<IEnumerable<Project>> GetAllByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an aggregate with the given ID exists.
    /// </summary>
    Task<bool> ExistsAsync(
        ProjectId id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of aggregates.
    /// Warning: This may be expensive for large datasets.
    /// </summary>
    Task<long> CountAsync(CancellationToken cancellationToken = default);
}

//<auto-generated />
/// <summary>
/// Repository for querying and managing Project aggregates.
/// </summary>
public partial class ProjectRepository : IProjectRepository
{
    private readonly IProjectFactory projectFactory;
    private readonly IObjectDocumentFactory objectDocumentFactory;
    private readonly IObjectIdProvider objectIdProvider;

    /// <summary>
    /// Gets the object name used for document storage.
    /// </summary>
    public static string ObjectName => "project";

    /// <summary>
    /// Initializes a new instance of the ProjectRepository class.
    /// </summary>
    /// <param name="projectFactory">Factory for creating Project instances.</param>
    /// <param name="objectDocumentFactory">Factory for managing object documents.</param>
    /// <param name="objectIdProvider">Provider for querying object identifiers.</param>
    public ProjectRepository(
        IProjectFactory projectFactory,
        IObjectDocumentFactory objectDocumentFactory,
        IObjectIdProvider objectIdProvider)
    {
        ArgumentNullException.ThrowIfNull(projectFactory);
        ArgumentNullException.ThrowIfNull(objectDocumentFactory);
        ArgumentNullException.ThrowIfNull(objectIdProvider);

        this.projectFactory = projectFactory;
        this.objectDocumentFactory = objectDocumentFactory;
        this.objectIdProvider = objectIdProvider;
    }

    public async Task<PagedResult<string>> GetObjectIdsAsync(
        string? continuationToken = null,
        int pageSize = 100,
        CancellationToken cancellationToken = default)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(pageSize, 1);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(pageSize, 1000);

        return await objectIdProvider.GetObjectIdsAsync(
            ObjectName,
            continuationToken,
            pageSize,
            cancellationToken);
    }

    public async Task<Project?> GetByIdAsync(
        ProjectId id,
        int? upToVersion = null,
        CancellationToken cancellationToken = default)
    {
        try
        {
            return await projectFactory.GetAsync(id, upToVersion);
        }
        catch (Exception)
        {
            return null;
        }
    }

    public async Task<(Project?, IObjectDocument?)> GetByIdWithDocumentAsync(
        ProjectId id,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var document = await objectDocumentFactory.GetAsync(ObjectName, id.ToString(), null, null);
            var obj = projectFactory.Create(document);
            await obj.Fold();
            return (obj, document);
        }
        catch (Exception)
        {
            return (null, null);
        }
    }

    public async Task<Project?> GetFirstByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(tag);

        var document = await objectDocumentFactory.GetFirstByObjectDocumentTag(ObjectName, tag);
        if (document == null)
        {
            return null;
        }

        var obj = projectFactory.Create(document);
        await obj.Fold();
        return obj;
    }

    public async Task<IEnumerable<Project>> GetAllByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(tag);

        var documents = await objectDocumentFactory.GetByObjectDocumentTag(ObjectName, tag);
        var items = new List<Project>();

        foreach (var document in documents)
        {
            var obj = projectFactory.Create(document);
            await obj.Fold();
            items.Add(obj);
        }

        return items;
    }

    public async Task<bool> ExistsAsync(
        ProjectId id,
        CancellationToken cancellationToken = default)
    {
        return await objectIdProvider.ExistsAsync(
            ObjectName,
            id.ToString(),
            cancellationToken);
    }

    public async Task<long> CountAsync(CancellationToken cancellationToken = default)
    {
        return await objectIdProvider.CountAsync(ObjectName, cancellationToken);
    }
}
