using ErikLieben.FA.ES;
using ErikLieben.FA.ES.Aggregates;
using ErikLieben.FA.ES.Documents;
using ErikLieben.FA.ES.Processors;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using TaskFlow.Domain.Events.WorkItem;
using TaskFlow.Domain.ValueObjects;
using TaskFlow.Domain.ValueObjects.WorkItem;

#nullable enable

namespace TaskFlow.Domain.Aggregates;

// <auto-generated />
/// <summary>
/// WorkItem aggregate root implementing event sourcing patterns.
/// </summary>
[GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
[ExcludeFromCodeCoverage]
public partial class WorkItem : Aggregate, IBase, IWorkItem
{

    /// <summary>
    /// Gets the logical object name for this aggregate type (AOT-friendly static member).
    /// </summary>
    public static string ObjectName => "workItem";

    /// <summary>
    /// Creates a new instance of the aggregate from an event stream (AOT-friendly factory).
    /// </summary>
    /// <param name="stream">The event stream for the aggregate.</param>
    /// <returns>A new instance of the aggregate.</returns>
    public static WorkItem Create(IEventStream stream) => new WorkItem(stream);

    /// <summary>
    /// Applies an event to the aggregate state by dispatching to the appropriate When method.
    /// </summary>
    /// <param name="event">The event to apply to the aggregate.</param>
    public override void Fold(IEvent @event)
    {
        switch (@event.EventType)
        {
            case "WorkItem.Planned":
                When(JsonEvent.To(@event, WorkItemPlannedJsonSerializerContext.Default.WorkItemPlanned));
                break;
            case "WorkItem.ResponsibilityAssigned":
                When(JsonEvent.To(@event, ResponsibilityAssignedJsonSerializerContext.Default.ResponsibilityAssigned));
                break;
            case "WorkItem.ResponsibilityRelinquished":
                When(JsonEvent.To(@event, ResponsibilityRelinquishedJsonSerializerContext.Default.ResponsibilityRelinquished));
                break;
            case "WorkItem.WorkCommenced":
                When(JsonEvent.To(@event, WorkCommencedJsonSerializerContext.Default.WorkCommenced));
                break;
            case "WorkItem.WorkCompleted":
                When(JsonEvent.To(@event, WorkCompletedJsonSerializerContext.Default.WorkCompleted));
                break;
            case "WorkItem.Revived":
                When(JsonEvent.To(@event, WorkItemRevivedJsonSerializerContext.Default.WorkItemRevived));
                break;
            case "WorkItem.Reprioritized":
                When(JsonEvent.To(@event, WorkItemReprioritizedJsonSerializerContext.Default.WorkItemReprioritized));
                break;
            case "WorkItem.EffortReestimated":
                When(JsonEvent.To(@event, EffortReestimatedJsonSerializerContext.Default.EffortReestimated));
                break;
            case "WorkItem.RequirementsRefined":
                When(JsonEvent.To(@event, RequirementsRefinedJsonSerializerContext.Default.RequirementsRefined));
                break;
            case "WorkItem.FeedbackProvided":
                When(JsonEvent.To(@event, FeedbackProvidedJsonSerializerContext.Default.FeedbackProvided));
                break;
            case "WorkItem.Relocated":
                When(JsonEvent.To(@event, WorkItemRelocatedJsonSerializerContext.Default.WorkItemRelocated));
                break;
            case "WorkItem.Retagged":
                When(JsonEvent.To(@event, WorkItemRetaggedJsonSerializerContext.Default.WorkItemRetagged));
                break;
            case "WorkItem.DeadlineEstablished":
                When(JsonEvent.To(@event, DeadlineEstablishedJsonSerializerContext.Default.DeadlineEstablished));
                break;
            case "WorkItem.DeadlineRemoved":
                When(JsonEvent.To(@event, DeadlineRemovedJsonSerializerContext.Default.DeadlineRemoved));
                break;
            case "WorkItem.MovedBackFromCompletedToInProgress":
                When(JsonEvent.To(@event, MovedBackFromCompletedToInProgressJsonSerializerContext.Default.MovedBackFromCompletedToInProgress));
                break;
            case "WorkItem.MovedBackFromCompletedToPlanned":
                When(JsonEvent.To(@event, MovedBackFromCompletedToPlannedJsonSerializerContext.Default.MovedBackFromCompletedToPlanned));
                break;
            case "WorkItem.MovedBackFromInProgressToPlanned":
                When(JsonEvent.To(@event, MovedBackFromInProgressToPlannedJsonSerializerContext.Default.MovedBackFromInProgressToPlanned));
                break;
            case "WorkItem.DragMarkedAsAccidental":
                When(JsonEvent.To(@event, DragMarkedAsAccidentalJsonSerializerContext.Default.DragMarkedAsAccidental));
                break;
        }

        PostWhen(Stream.Document, @event);
    }

    [GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
    [ExcludeFromCodeCoverage]
    protected override void GeneratedSetup()
    {
        Stream.RegisterEvent<WorkItemPlanned>(
      "WorkItem.Planned",
      WorkItemPlannedJsonSerializerContext.Default.WorkItemPlanned);
        Stream.RegisterEvent<ResponsibilityAssigned>(
            "WorkItem.ResponsibilityAssigned",
            ResponsibilityAssignedJsonSerializerContext.Default.ResponsibilityAssigned);
        Stream.RegisterEvent<ResponsibilityRelinquished>(
            "WorkItem.ResponsibilityRelinquished",
            ResponsibilityRelinquishedJsonSerializerContext.Default.ResponsibilityRelinquished);
        Stream.RegisterEvent<WorkCommenced>(
            "WorkItem.WorkCommenced",
            WorkCommencedJsonSerializerContext.Default.WorkCommenced);
        Stream.RegisterEvent<WorkCompleted>(
            "WorkItem.WorkCompleted",
            WorkCompletedJsonSerializerContext.Default.WorkCompleted);
        Stream.RegisterEvent<WorkItemRevived>(
            "WorkItem.Revived",
            WorkItemRevivedJsonSerializerContext.Default.WorkItemRevived);
        Stream.RegisterEvent<WorkItemReprioritized>(
            "WorkItem.Reprioritized",
            WorkItemReprioritizedJsonSerializerContext.Default.WorkItemReprioritized);
        Stream.RegisterEvent<EffortReestimated>(
            "WorkItem.EffortReestimated",
            EffortReestimatedJsonSerializerContext.Default.EffortReestimated);
        Stream.RegisterEvent<RequirementsRefined>(
            "WorkItem.RequirementsRefined",
            RequirementsRefinedJsonSerializerContext.Default.RequirementsRefined);
        Stream.RegisterEvent<FeedbackProvided>(
            "WorkItem.FeedbackProvided",
            FeedbackProvidedJsonSerializerContext.Default.FeedbackProvided);
        Stream.RegisterEvent<WorkItemRelocated>(
            "WorkItem.Relocated",
            WorkItemRelocatedJsonSerializerContext.Default.WorkItemRelocated);
        Stream.RegisterEvent<WorkItemRetagged>(
            "WorkItem.Retagged",
            WorkItemRetaggedJsonSerializerContext.Default.WorkItemRetagged);
        Stream.RegisterEvent<DeadlineEstablished>(
            "WorkItem.DeadlineEstablished",
            DeadlineEstablishedJsonSerializerContext.Default.DeadlineEstablished);
        Stream.RegisterEvent<DeadlineRemoved>(
            "WorkItem.DeadlineRemoved",
            DeadlineRemovedJsonSerializerContext.Default.DeadlineRemoved);
        Stream.RegisterEvent<MovedBackFromCompletedToInProgress>(
            "WorkItem.MovedBackFromCompletedToInProgress",
            MovedBackFromCompletedToInProgressJsonSerializerContext.Default.MovedBackFromCompletedToInProgress);
        Stream.RegisterEvent<MovedBackFromCompletedToPlanned>(
            "WorkItem.MovedBackFromCompletedToPlanned",
            MovedBackFromCompletedToPlannedJsonSerializerContext.Default.MovedBackFromCompletedToPlanned);
        Stream.RegisterEvent<MovedBackFromInProgressToPlanned>(
            "WorkItem.MovedBackFromInProgressToPlanned",
            MovedBackFromInProgressToPlannedJsonSerializerContext.Default.MovedBackFromInProgressToPlanned);
        Stream.RegisterEvent<DragMarkedAsAccidental>(
            "WorkItem.DragMarkedAsAccidental",
            DragMarkedAsAccidentalJsonSerializerContext.Default.DragMarkedAsAccidental);
        Stream.SetSnapShotType(WorkItemJsonSerializerContext.Default.WorkItemSnapshot);
        Stream.SetAggregateType(WorkItemJsonSerializerContext.Default.WorkItem);

        // Freeze the EventTypeRegistry for optimized lookups (~50% faster)
        Stream.EventTypeRegistry.Freeze();
    }
}

// <auto-generated />
/// <summary>
/// Interface defining the public state properties of WorkItem.
/// </summary>
public interface IWorkItem
{
    public Guid WorkItemId { get; }
    public String? ProjectId { get; }
    public String? Title { get; }
    public String? Description { get; }
    public WorkItemPriority Priority { get; }
    public WorkItemStatus Status { get; }
    public String? AssignedTo { get; }
    public Nullable<System.DateTime> Deadline { get; }
    public Nullable<System.Int32> EstimatedHours { get; }
    public List<System.String>? Tags { get; }
    public List<TaskFlow.Domain.ValueObjects.WorkItem.WorkItemComment>? Comments { get; }
    public List<TaskFlow.Domain.ValueObjects.WorkItem.LocalizedTitle>? TitleTranslations { get; }
    public ObjectMetadata<TaskFlow.Domain.ValueObjects.WorkItemId>? Metadata { get; }
}

// <auto-generated />
/// <summary>
/// Snapshot record for persisting WorkItem aggregate state.
/// </summary>
[GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
[ExcludeFromCodeCoverage]
public record WorkItemSnapshot : IWorkItem
{
    public required Guid WorkItemId { get; init; }
    public required String? ProjectId { get; init; }
    public required String? Title { get; init; }
    public required String? Description { get; init; }
    public required WorkItemPriority Priority { get; init; }
    public required WorkItemStatus Status { get; init; }
    public required String? AssignedTo { get; init; }
    public required Nullable<System.DateTime> Deadline { get; init; }
    public required Nullable<System.Int32> EstimatedHours { get; init; }
    public required List<System.String>? Tags { get; init; }
    public required List<TaskFlow.Domain.ValueObjects.WorkItem.WorkItemComment>? Comments { get; init; }
    public required List<TaskFlow.Domain.ValueObjects.WorkItem.LocalizedTitle>? TitleTranslations { get; init; }
    public required ObjectMetadata<TaskFlow.Domain.ValueObjects.WorkItemId>? Metadata { get; init; }
}

[JsonSerializable(typeof(WorkItemPlanned))]
[JsonSerializable(typeof(ResponsibilityAssigned))]
[JsonSerializable(typeof(ResponsibilityRelinquished))]
[JsonSerializable(typeof(WorkCommenced))]
[JsonSerializable(typeof(WorkCompleted))]
[JsonSerializable(typeof(WorkItemRevived))]
[JsonSerializable(typeof(WorkItemReprioritized))]
[JsonSerializable(typeof(EffortReestimated))]
[JsonSerializable(typeof(RequirementsRefined))]
[JsonSerializable(typeof(FeedbackProvided))]
[JsonSerializable(typeof(WorkItemRelocated))]
[JsonSerializable(typeof(WorkItemRetagged))]
[JsonSerializable(typeof(DeadlineEstablished))]
[JsonSerializable(typeof(DeadlineRemoved))]
[JsonSerializable(typeof(MovedBackFromCompletedToInProgress))]
[JsonSerializable(typeof(MovedBackFromCompletedToPlanned))]
[JsonSerializable(typeof(MovedBackFromInProgressToPlanned))]
[JsonSerializable(typeof(DragMarkedAsAccidental))]
[JsonSerializable(typeof(WorkItemSnapshot))]
[JsonSerializable(typeof(WorkItem))]
[JsonSerializable(typeof(WorkItemId))]
[JsonSerializable(typeof(System.Enum))]
[JsonSerializable(typeof(System.String))]
[JsonSerializable(typeof(TaskFlow.Domain.ValueObjects.WorkItemId))]
// <auto-generated />
/// <summary>
/// JSON serializer context for WorkItem types.
/// </summary>
internal partial class WorkItemJsonSerializerContext : JsonSerializerContext
{
}

//<auto-generated />
/// <summary>
/// Factory interface for creating WorkItem aggregate instances.
/// </summary>
public partial interface IWorkItemFactory : IAggregateFactory<WorkItem, WorkItemId>
{
}

//<auto-generated />
/// <summary>
/// Factory for creating and loading WorkItem aggregate instances from documents and event streams.
/// </summary>
[GeneratedCode("ErikLieben.FA.ES", "1.0.0")]
[ExcludeFromCodeCoverage]
public partial class WorkItemFactory : IWorkItemFactory
{
    private readonly IEventStreamFactory eventStreamFactory;
    private readonly IObjectDocumentFactory objectDocumentFactory;
    private readonly IServiceProvider serviceProvider;

    /// <summary>
    /// Gets the object name used for document storage.
    /// </summary>
    public static string ObjectName => "workItem";

    /// <summary>
    /// Gets the object name used for document storage.
    /// </summary>
    /// <returns>The object name.</returns>
    public string GetObjectName()
    {
        return ObjectName;
    }

    /// <summary>
    /// Initializes a new instance of the WorkItemFactory class.
    /// </summary>
    /// <param name="serviceProvider">Service provider for dependency injection.</param>
    /// <param name="eventStreamFactory">Factory for creating event streams.</param>
    /// <param name="objectDocumentFactory">Factory for creating and managing object documents.</param>
    public WorkItemFactory(
      IServiceProvider serviceProvider,
      IEventStreamFactory eventStreamFactory,
      IObjectDocumentFactory objectDocumentFactory)
    {
        ArgumentNullException.ThrowIfNull(serviceProvider);
        ArgumentNullException.ThrowIfNull(eventStreamFactory);
        ArgumentNullException.ThrowIfNull(objectDocumentFactory);

        this.serviceProvider = serviceProvider;
        this.eventStreamFactory = eventStreamFactory;
        this.objectDocumentFactory = objectDocumentFactory;
    }

    /// <summary>
    /// Creates a WorkItem instance from an event stream.
    /// </summary>
    /// <param name="eventStream">The event stream to create the aggregate from.</param>
    /// <returns>A new WorkItem instance.</returns>
    public WorkItem Create(IEventStream eventStream)
    {
        ArgumentNullException.ThrowIfNull(eventStream);

        // get the params required from DI

        return new WorkItem(eventStream);
    }

    /// <summary>
    /// Creates a WorkItem instance from an object document.
    /// </summary>
    /// <param name="document">The object document to create the aggregate from.</param>
    /// <returns>A new WorkItem instance.</returns>
    public WorkItem Create(IObjectDocument document)
    {
        ArgumentNullException.ThrowIfNull(document);

        // get the params required from DI

        var eventStream = eventStreamFactory.Create(document);
        return new WorkItem(eventStream);
    }

    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    /// <summary>
    /// Creates a new WorkItem aggregate with the specified identifier.
    /// </summary>
    /// <param name="id">The identifier for the new aggregate.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>A new WorkItem instance.</returns>
    public async Task<WorkItem> CreateAsync(WorkItemId id, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetOrCreateAsync(ObjectName, id.ToString(), null, null);

        var obj = Create(document);
        await obj.Fold();
        return obj;
    }

    /// <summary>
    /// Creates a new WorkItem aggregate with the specified identifier and first event.
    /// </summary>
    /// <typeparam name="T">The type of the first event.</typeparam>
    /// <param name="id">The identifier for the new aggregate.</param>
    /// <param name="firstEvent">The first event to append to the aggregate's event stream.</param>
    /// <param name="metadata">Optional metadata to attach to the event.</param>
    /// <returns>A new WorkItem instance with the event applied.</returns>
    protected async Task<WorkItem> CreateAsync<T>(WorkItemId id, T firstEvent, ActionMetadata? metadata = null) where T : class
    {
        var document = await this.objectDocumentFactory.GetOrCreateAsync(ObjectName, id.ToString(), null, null);

        var eventStream = eventStreamFactory.Create(document);
        var obj = new WorkItem(eventStream);
        await eventStream.Session(context => context.Append(firstEvent, metadata));
        await obj.Fold();
        return obj;
    }

    /// <summary>
    /// Gets an existing WorkItem aggregate by identifier.
    /// </summary>
    /// <param name="id">The identifier of the aggregate to retrieve.</param>
    /// <param name="upToVersion">Optional maximum event version to fold. If null, loads to current state.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>The loaded WorkItem instance.</returns>
    [Obsolete("Use IWorkItemRepository.GetByIdAsync instead. This method will be removed in a future version.")]
    public async Task<WorkItem> GetAsync(WorkItemId id, int? upToVersion = null, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetAsync(ObjectName, id.ToString(), null, null);

        // Create event stream
        var eventStream = eventStreamFactory.Create(document);

        // Create aggregate FIRST to register upcasters and event handlers
        var obj = new WorkItem(eventStream);

        // Read events up to version WITH upcasting applied
        var events = await eventStream.ReadAsync(0, upToVersion);

        // Fold events into the aggregate
        foreach (var e in events)
        {
            obj.Fold(e);
        }

        return obj;
    }

    /// <summary>
    /// Gets an existing WorkItem aggregate by identifier along with its document.
    /// </summary>
    /// <param name="id">The identifier of the aggregate to retrieve.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>A tuple containing the loaded WorkItem instance and its document.</returns>
    [Obsolete("Use IWorkItemRepository.GetByIdWithDocumentAsync instead. This method will be removed in a future version.")]
    public async Task<(WorkItem, IObjectDocument)> GetWithDocumentAsync(WorkItemId id, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetAsync(ObjectName, id.ToString(), null, null);
        var obj = Create(document);
        await obj.Fold();
        return (obj, document);
    }

    /// <summary>
    /// Gets the first WorkItem aggregate with the specified document tag.
    /// </summary>
    /// <param name="tag">The document tag to search for.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>The first matching WorkItem instance, or null if not found.</returns>
    [Obsolete("Use IWorkItemRepository.GetFirstByDocumentTagAsync instead. This method will be removed in a future version.")]
    public async Task<WorkItem?> GetFirstByDocumentTag(string tag, CancellationToken cancellationToken = default)
    {
        var document = await this.objectDocumentFactory.GetFirstByObjectDocumentTag(ObjectName, tag);
        if (document == null)
        {
            return null;
        }
        var obj = Create(document);
        await obj.Fold();
        return obj;
    }

    /// <summary>
    /// Gets all WorkItem aggregates with the specified document tag.
    /// </summary>
    /// <param name="tag">The document tag to search for.</param>
    /// <param name="cancellationToken">A token to cancel the operation.</param>
    /// <returns>A collection of all matching WorkItem instances.</returns>
    [Obsolete("Use IWorkItemRepository.GetAllByDocumentTagAsync instead. This method will be removed in a future version.")]
    public async Task<IEnumerable<WorkItem>> GetAllByDocumentTag(string tag, CancellationToken cancellationToken = default)
    {
        var documents = (await this.objectDocumentFactory.GetByObjectDocumentTag(ObjectName, tag));
        var items = new List<WorkItem>();
        foreach (var document in documents)
        {
            var obj = Create(document);
            await obj.Fold();
            items.Add(obj);
        }
        return items;
    }
}

//<auto-generated />
public partial interface IWorkItemRepository
{
    /// <summary>
    /// Gets a paginated list of all WorkItem object IDs using continuation tokens.
    /// </summary>
    Task<PagedResult<string>> GetObjectIdsAsync(
        string? continuationToken = null,
        int pageSize = 100,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a single aggregate by ID.
    /// </summary>
    /// <param name="upToVersion">Optional: The maximum event version to fold. If null, loads to current state.</param>
    Task<WorkItem?> GetByIdAsync(
        WorkItemId id,
        int? upToVersion = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a single aggregate by ID along with its document.
    /// </summary>
    Task<(WorkItem?, IObjectDocument?)> GetByIdWithDocumentAsync(
        WorkItemId id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the first aggregate with the specified document tag.
    /// </summary>
    Task<WorkItem?> GetFirstByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all aggregates with the specified document tag.
    /// </summary>
    Task<IEnumerable<WorkItem>> GetAllByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an aggregate with the given ID exists.
    /// </summary>
    Task<bool> ExistsAsync(
        WorkItemId id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of aggregates.
    /// Warning: This may be expensive for large datasets.
    /// </summary>
    Task<long> CountAsync(CancellationToken cancellationToken = default);
}

//<auto-generated />
/// <summary>
/// Repository for querying and managing WorkItem aggregates.
/// </summary>
public partial class WorkItemRepository : IWorkItemRepository
{
    private readonly IWorkItemFactory workitemFactory;
    private readonly IObjectDocumentFactory objectDocumentFactory;
    private readonly IObjectIdProvider objectIdProvider;

    /// <summary>
    /// Gets the object name used for document storage.
    /// </summary>
    public static string ObjectName => "workItem";

    /// <summary>
    /// Initializes a new instance of the WorkItemRepository class.
    /// </summary>
    /// <param name="workitemFactory">Factory for creating WorkItem instances.</param>
    /// <param name="objectDocumentFactory">Factory for managing object documents.</param>
    /// <param name="objectIdProvider">Provider for querying object identifiers.</param>
    public WorkItemRepository(
        IWorkItemFactory workitemFactory,
        IObjectDocumentFactory objectDocumentFactory,
        IObjectIdProvider objectIdProvider)
    {
        ArgumentNullException.ThrowIfNull(workitemFactory);
        ArgumentNullException.ThrowIfNull(objectDocumentFactory);
        ArgumentNullException.ThrowIfNull(objectIdProvider);

        this.workitemFactory = workitemFactory;
        this.objectDocumentFactory = objectDocumentFactory;
        this.objectIdProvider = objectIdProvider;
    }

    public async Task<PagedResult<string>> GetObjectIdsAsync(
        string? continuationToken = null,
        int pageSize = 100,
        CancellationToken cancellationToken = default)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(pageSize, 1);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(pageSize, 1000);

        return await objectIdProvider.GetObjectIdsAsync(
            ObjectName,
            continuationToken,
            pageSize,
            cancellationToken);
    }

    public async Task<WorkItem?> GetByIdAsync(
        WorkItemId id,
        int? upToVersion = null,
        CancellationToken cancellationToken = default)
    {
        try
        {
            return await workitemFactory.GetAsync(id, upToVersion);
        }
        catch (Exception)
        {
            return null;
        }
    }

    public async Task<(WorkItem?, IObjectDocument?)> GetByIdWithDocumentAsync(
        WorkItemId id,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var document = await objectDocumentFactory.GetAsync(ObjectName, id.ToString(), null, null);
            var obj = workitemFactory.Create(document);
            await obj.Fold();
            return (obj, document);
        }
        catch (Exception)
        {
            return (null, null);
        }
    }

    public async Task<WorkItem?> GetFirstByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(tag);

        var document = await objectDocumentFactory.GetFirstByObjectDocumentTag(ObjectName, tag);
        if (document == null)
        {
            return null;
        }

        var obj = workitemFactory.Create(document);
        await obj.Fold();
        return obj;
    }

    public async Task<IEnumerable<WorkItem>> GetAllByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(tag);

        var documents = await objectDocumentFactory.GetByObjectDocumentTag(ObjectName, tag);
        var items = new List<WorkItem>();

        foreach (var document in documents)
        {
            var obj = workitemFactory.Create(document);
            await obj.Fold();
            items.Add(obj);
        }

        return items;
    }

    public async Task<bool> ExistsAsync(
        WorkItemId id,
        CancellationToken cancellationToken = default)
    {
        return await objectIdProvider.ExistsAsync(
            ObjectName,
            id.ToString(),
            cancellationToken);
    }

    public async Task<long> CountAsync(CancellationToken cancellationToken = default)
    {
        return await objectIdProvider.CountAsync(ObjectName, cancellationToken);
    }
}
