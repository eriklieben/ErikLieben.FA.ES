import { Component, inject, signal, OnInit, effect, HostListener } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatDividerModule } from '@angular/material/divider';
import { MatTabsModule } from '@angular/material/tabs';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { CodeHighlighterService } from '../../core/services/code-highlighter.service';
import { ThemeService } from '../../core/services/theme.service';

interface NavItem {
  id: string;
  label: string;
  icon: string;
}

@Component({
  selector: 'app-minimal-api',
  imports: [
    CommonModule,
    MatCardModule,
    MatButtonModule,
    MatIconModule,
    MatDividerModule,
    MatTabsModule
  ],
  templateUrl: './minimal-api.component.html',
  styleUrl: './minimal-api.component.css'
})
export class MinimalApiComponent implements OnInit {
  private readonly codeHighlighter = inject(CodeHighlighterService);
  private readonly themeService = inject(ThemeService);
  private readonly sanitizer = inject(DomSanitizer);

  // Tab state
  commandTab = signal<'binding' | 'manual'>('binding');
  queryTab = signal<'binding' | 'manual'>('binding');
  projectionTab = signal<'binding' | 'manual'>('binding');

  // Navigation items
  readonly navItems: NavItem[] = [
    { id: 'installation', label: 'Installation', icon: 'download' },
    { id: 'setup', label: 'Setup', icon: 'settings' },
    { id: 'binding', label: 'Parameter Binding', icon: 'link' },
    { id: 'commands', label: 'Commands', icon: 'edit' },
    { id: 'queries', label: 'Queries', icon: 'search' },
    { id: 'projections', label: 'Projection Updates', icon: 'view_quilt' },
    { id: 'complete-example', label: 'Complete Example', icon: 'integration_instructions' }
  ];

  // Active section tracking
  activeSection = signal<string>('installation');

  // Step hover state
  hoveredSetupStep = signal<number | null>(null);
  hoveredBindingStep = signal<number | null>(null);
  hoveredCommandStep = signal<number | null>(null);
  hoveredQueryStep = signal<number | null>(null);
  hoveredProjectionStep = signal<number | null>(null);

  // Highlighted code HTML
  installCodeHtml = signal<SafeHtml>('');
  setupCodeHtml = signal<SafeHtml>('');
  bindingCodeHtml = signal<SafeHtml>('');
  commandCodeHtml = signal<SafeHtml>('');
  commandBindingCodeHtml = signal<SafeHtml>('');
  queryCodeHtml = signal<SafeHtml>('');
  queryBindingCodeHtml = signal<SafeHtml>('');
  projectionCodeHtml = signal<SafeHtml>('');
  projectionBindingCodeHtml = signal<SafeHtml>('');
  completeExampleCodeHtml = signal<SafeHtml>('');

  // Code samples - Installation
  private readonly installCodeSample = `# Add the Minimal APIs binding package
dotnet add package ErikLieben.FA.ES.AspNetCore.MinimalApis

# Also need the core package and a storage provider
dotnet add package ErikLieben.FA.ES
dotnet add package ErikLieben.FA.ES.AzureStorage`;

  // Code samples - Setup
  private readonly setupCodeSample = `var builder = WebApplication.CreateBuilder(args);

// Configure Azure Blob Storage
builder.Services.AddAzureClients(clientBuilder =>
{
    clientBuilder.AddBlobServiceClient(builder.Configuration.GetConnectionString("Storage"))
        .WithName("EventStore");
});

// Configure Event Store with Blob Storage backend
builder.Services.ConfigureBlobEventStore(new EventStreamBlobSettings("EventStore"));
builder.Services.ConfigureEventStore(new EventStreamDefaultTypeSettings("blob"));

// Register aggregate and projection factories (generated by CLI)
builder.Services.ConfigureTaskFlowDomainFactory();

// Add Minimal API bindings
builder.Services.AddEventStoreMinimalApis();

var app = builder.Build();`;

  // Code samples - Binding Overview
  private readonly bindingCodeSample = `// [EventStream] - Load aggregate from route parameter
app.MapPost("/orders/{id}/items", async (
    [EventStream] Order order,           // Loaded from route "id"
    [FromBody] AddItemCommand command) =>
{
    order.AddItem(command.ProductId, command.Quantity);
    return Results.Ok();
});

// [EventStream("routeParam")] - Custom route parameter name
app.MapPost("/orders/{orderId}/ship", async (
    [EventStream("orderId")] Order order,  // Loaded from route "orderId"
    [FromBody] ShipCommand command) =>
{
    order.Ship(command.Carrier);
    return Results.Ok();
});

// [EventStream(CreateIfNotExists = true)] - Create new aggregate
app.MapPost("/orders", async (
    [EventStream(CreateIfNotExists = true)] Order order,
    [FromBody] CreateOrderCommand command) =>
{
    order.Create(command.CustomerId);
    return Results.Created($"/orders/{order.Id}", new { order.Id });
});

// [Projection] - Load projection with default blob name
app.MapGet("/dashboard", async ([Projection] DashboardProjection dashboard) =>
{
    return Results.Ok(dashboard);
});

// [Projection("{id}")] - Routed projection with blob name from route
app.MapGet("/orders/{id}/summary", async (
    [Projection("{id}")] OrderSummaryProjection summary) =>
{
    return Results.Ok(summary);
});`;

  // Code samples - Commands with Binding
  private readonly commandBindingCodeSample = `// Create a new work item with [EventStream]
app.MapPost("/api/workitems", async (
    [EventStream(CreateIfNotExists = true)] WorkItem workItem,
    [FromBody] CreateWorkItemRequest request) =>
{
    // Execute domain command - events are appended internally
    await workItem.Create(
        request.Title,
        request.Description,
        request.ProjectId,
        request.Priority);

    return Results.Created($"/api/workitems/{workItem.Metadata!.Id}",
        new { id = workItem.Metadata.Id });
})
.AndUpdateProjectionToLatest<ActiveWorkItems>();  // Auto-update projection

// Update an existing work item
app.MapPut("/api/workitems/{id}/assign", async (
    [EventStream] WorkItem workItem,  // Loaded from route "id"
    [FromBody] AssignWorkItemRequest request) =>
{
    if (workItem.Metadata?.Id == null)
        return Results.NotFound();

    await workItem.AssignTo(request.AssigneeId);
    return Results.Ok(new { message = "Work item assigned" });
})
.AndUpdateProjectionToLatest<ActiveWorkItems>();

// Ship an order with custom route parameter
app.MapPost("/api/orders/{orderId}/ship", async (
    [EventStream("orderId")] Order order,
    [FromBody] ShipOrderRequest request) =>
{
    order.Ship(request.CarrierName, request.TrackingNumber);
    return Results.Ok();
})
.WithProjectionOutput<OrderSummaryProjection>("{orderId}");`;

  // Code samples - Commands Manual
  private readonly commandCodeSample = `// Create a new work item
app.MapPost("/api/workitems", async (
    CreateWorkItemRequest request,
    IWorkItemFactory factory) =>
{
    // Create new aggregate with generated ID
    var workItemId = WorkItemId.New();
    var workItem = await factory.CreateAsync(workItemId);

    // Execute domain command - this appends events internally
    await workItem.Create(
        request.Title,
        request.Description,
        request.ProjectId,
        request.Priority);

    // Events are automatically persisted when command completes
    return Results.Created($"/api/workitems/{workItemId}", new { id = workItemId });
});

// Update an existing work item
app.MapPut("/api/workitems/{id}/assign", async (
    string id,
    AssignWorkItemRequest request,
    IWorkItemFactory factory) =>
{
    // Load aggregate from event stream (replays all events)
    var workItem = await factory.GetAsync(new WorkItemId(Guid.Parse(id)));

    if (workItem.Metadata?.Id == null)
        return Results.NotFound();

    // Execute domain command
    await workItem.AssignTo(request.AssigneeId);

    return Results.Ok(new { message = "Work item assigned" });
});`;

  // Code samples - Queries with Binding
  private readonly queryBindingCodeSample = `// Query single aggregate by ID using [EventStream]
app.MapGet("/api/workitems/{id}", async ([EventStream] WorkItem workItem) =>
{
    if (workItem.Metadata?.Id == null)
        return Results.NotFound();

    return Results.Ok(new
    {
        id = workItem.Metadata.Id.Value,
        title = workItem.Title,
        status = workItem.Status.ToString(),
        assignedTo = workItem.AssignedTo
    });
});

// Query from projection using [Projection]
app.MapGet("/api/workitems", async ([Projection] ActiveWorkItems projection) =>
{
    return Results.Ok(new
    {
        items = projection.Items.Select(i => new
        {
            id = i.Id,
            title = i.Title,
            status = i.Status
        }),
        totalCount = projection.Items.Count
    });
});

// Routed projection - per-order summary
app.MapGet("/api/orders/{id}/summary", async (
    [Projection("{id}")] OrderSummaryProjection summary) =>
{
    return Results.Ok(new
    {
        orderId = summary.OrderId,
        customerName = summary.CustomerName,
        totalAmount = summary.TotalAmount,
        itemCount = summary.ItemCount
    });
});

// Multiple route parameters in projection blob name
app.MapGet("/api/tenants/{tenantId}/orders/{orderId}/summary", async (
    [Projection("{tenantId}/{orderId}")] OrderSummaryProjection summary) =>
{
    return Results.Ok(summary);
});`;

  // Code samples - Queries Manual
  private readonly queryCodeSample = `// Query single aggregate by ID
app.MapGet("/api/workitems/{id}", async (
    string id,
    IWorkItemFactory factory) =>
{
    var workItem = await factory.GetAsync(new WorkItemId(Guid.Parse(id)));

    if (workItem.Metadata?.Id == null)
        return Results.NotFound();

    return Results.Ok(new
    {
        id = workItem.Metadata.Id.Value,
        title = workItem.Title,
        status = workItem.Status.ToString(),
        assignedTo = workItem.AssignedTo
    });
});

// Query from projection for lists
app.MapGet("/api/workitems", async (
    IProjectionFactory<ActiveWorkItems> projectionFactory) =>
{
    var projection = await projectionFactory.GetAsync();

    // Optionally update to latest before returning
    await projection.UpdateToLatestVersion();

    return Results.Ok(new
    {
        items = projection.Items.Select(i => new
        {
            id = i.Id,
            title = i.Title,
            status = i.Status
        }),
        totalCount = projection.Items.Count
    });
});`;

  // Code samples - Projections with Binding
  private readonly projectionBindingCodeSample = `// .AndUpdateProjectionToLatest<T>() - Update after endpoint execution
app.MapPost("/api/workitems", async (
    [EventStream(CreateIfNotExists = true)] WorkItem workItem,
    [FromBody] CreateWorkItemRequest request) =>
{
    await workItem.Create(request.Title, request.Description);
    return Results.Created($"/api/workitems/{workItem.Metadata!.Id}", new { success = true });
})
.AndUpdateProjectionToLatest<ActiveWorkItems>();  // Updates after success

// Multiple projections - chain them
app.MapPost("/api/workitems/{id}/complete", async ([EventStream] WorkItem workItem) =>
{
    workItem.Complete();
    return Results.Ok();
})
.AndUpdateProjectionToLatest<ActiveWorkItems>()
.AndUpdateProjectionToLatest<CompletedWorkItems>()
.AndUpdateProjectionToLatest<DashboardStats>();

// Routed projection with blob name from route
app.MapPost("/api/orders/{id}/items", async (
    [EventStream] Order order,
    [FromBody] AddItemRequest request) =>
{
    order.AddItem(request.ProductId, request.Quantity);
    return Results.Ok();
})
.WithProjectionOutput<OrderSummaryProjection>("{id}");  // Per-order projection

// .WithProjectionOutput (alias for .AndUpdateProjectionToLatest)
app.MapPost("/api/orders/{id}/complete", async ([EventStream] Order order) =>
{
    order.Complete();
    return Results.Ok();
})
.WithProjectionOutput<OrderSummaryProjection>("{id}")
.WithProjectionOutput<ActiveOrders>();`;

  // Code samples - Projections Manual
  private readonly projectionCodeSample = `// Strategy 1: Update projection after command (synchronous)
app.MapPost("/api/workitems", async (
    CreateWorkItemRequest request,
    IWorkItemFactory factory,
    IProjectionFactory<ActiveWorkItems> projectionFactory) =>
{
    var workItem = await factory.CreateAsync(WorkItemId.New());
    await workItem.Create(request.Title, request.Description);

    // Update projection immediately after command
    var projection = await projectionFactory.GetAsync();
    await projection.UpdateToLatestVersion();

    return Results.Created($"/api/workitems/{workItem.Metadata!.Id}", new { success = true });
});

// Strategy 2: Background service for periodic updates
public class ProjectionUpdateService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            var projection = await _projectionFactory.GetAsync();
            await projection.UpdateToLatestVersion();

            await Task.Delay(TimeSpan.FromSeconds(30), stoppingToken);
        }
    }
}

// Strategy 3: On-demand update endpoint
app.MapPost("/api/projections/refresh", async (
    IProjectionFactory<ActiveWorkItems> activeItemsFactory,
    IProjectionFactory<ProjectKanbanBoard> kanbanFactory) =>
{
    var activeItems = await activeItemsFactory.GetAsync();
    var kanban = await kanbanFactory.GetAsync();

    await Task.WhenAll(
        activeItems.UpdateToLatestVersion(),
        kanban.UpdateToLatestVersion());

    return Results.Ok(new { message = "Projections updated" });
});`;

  // Code samples - Complete Example
  private readonly completeExampleCodeSample = `using ErikLieben.FA.ES.AspNetCore.MinimalApis;
using ErikLieben.FA.ES.AspNetCore.MinimalApis.Extensions;

var builder = WebApplication.CreateBuilder(args);

// Setup (same as before)
builder.Services.ConfigureEventStore(new EventStreamDefaultTypeSettings("blob"));
builder.Services.ConfigureBlobEventStore(new EventStreamBlobSettings("Store"));
builder.Services.ConfigureTaskFlowDomainFactory();
builder.Services.AddEventStoreMinimalApis();

var app = builder.Build();

// ============================================
// Order Management API - Clean & Minimal
// ============================================

// Create order
app.MapPost("/orders", async (
    [EventStream(CreateIfNotExists = true)] Order order,
    [FromBody] CreateOrderRequest request) =>
{
    order.Create(request.CustomerId, request.ShippingAddress);
    return Results.Created($"/orders/{order.Id}", new { order.Id });
})
.AndUpdateProjectionToLatest<ActiveOrders>();

// Get order
app.MapGet("/orders/{id}", async ([EventStream] Order order) =>
    Results.Ok(new { order.Id, order.Status, order.TotalAmount }));

// Add item to order
app.MapPost("/orders/{id}/items", async (
    [EventStream] Order order,
    [FromBody] AddItemRequest request) =>
{
    order.AddItem(request.ProductId, request.Quantity, request.Price);
    return Results.Ok();
})
.WithProjectionOutput<OrderSummaryProjection>("{id}");

// Ship order
app.MapPost("/orders/{id}/ship", async (
    [EventStream] Order order,
    [FromBody] ShipRequest request) =>
{
    order.Ship(request.Carrier, request.TrackingNumber);
    return Results.Ok();
})
.WithProjectionOutput<OrderSummaryProjection>("{id}")
.AndUpdateProjectionToLatest<ActiveOrders>();

// Get order summary (routed projection)
app.MapGet("/orders/{id}/summary", async (
    [Projection("{id}")] OrderSummaryProjection summary) =>
    Results.Ok(summary));

// Dashboard (global projection)
app.MapGet("/dashboard", async ([Projection] DashboardProjection dashboard) =>
    Results.Ok(new { dashboard.TotalOrders, dashboard.TotalRevenue }));

app.Run();`;

  constructor() {
    // Re-highlight code when theme changes
    effect(() => {
      this.themeService.theme();
      this.highlightCodeSamples();
    });
  }

  ngOnInit(): void {
    this.highlightCodeSamples();
    this.updateActiveSection();
  }

  @HostListener('window:scroll')
  onScroll(): void {
    this.updateActiveSection();
  }

  private updateActiveSection(): void {
    const sections = this.navItems.map(item => ({
      id: item.id,
      element: document.getElementById(item.id)
    }));

    const scrollPosition = window.scrollY + 100;

    for (let i = sections.length - 1; i >= 0; i--) {
      const section = sections[i];
      if (section.element && section.element.offsetTop <= scrollPosition) {
        this.activeSection.set(section.id);
        return;
      }
    }

    this.activeSection.set('installation');
  }

  scrollToSection(event: Event, sectionId: string): void {
    event.preventDefault();
    const element = document.getElementById(sectionId);
    if (element) {
      element.scrollIntoView({ behavior: 'smooth', block: 'start' });
      this.activeSection.set(sectionId);
    }
  }

  onSetupCodeHover(event: MouseEvent): void {
    const target = event.target as HTMLElement;
    const line = target.closest('.step-line');
    if (line) {
      if (line.classList.contains('step-1')) this.hoveredSetupStep.set(1);
      else if (line.classList.contains('step-2')) this.hoveredSetupStep.set(2);
      else if (line.classList.contains('step-3')) this.hoveredSetupStep.set(3);
      else if (line.classList.contains('step-4')) this.hoveredSetupStep.set(4);
    } else {
      this.hoveredSetupStep.set(null);
    }
  }

  onBindingCodeHover(event: MouseEvent): void {
    const target = event.target as HTMLElement;
    const line = target.closest('.step-line');
    if (line) {
      if (line.classList.contains('step-1')) this.hoveredBindingStep.set(1);
      else if (line.classList.contains('step-2')) this.hoveredBindingStep.set(2);
      else if (line.classList.contains('step-3')) this.hoveredBindingStep.set(3);
      else if (line.classList.contains('step-4')) this.hoveredBindingStep.set(4);
    } else {
      this.hoveredBindingStep.set(null);
    }
  }

  onCommandCodeHover(event: MouseEvent): void {
    const target = event.target as HTMLElement;
    const line = target.closest('.step-line');
    if (line) {
      if (line.classList.contains('step-1')) this.hoveredCommandStep.set(1);
      else if (line.classList.contains('step-2')) this.hoveredCommandStep.set(2);
      else if (line.classList.contains('step-3')) this.hoveredCommandStep.set(3);
    } else {
      this.hoveredCommandStep.set(null);
    }
  }

  onQueryCodeHover(event: MouseEvent): void {
    const target = event.target as HTMLElement;
    const line = target.closest('.step-line');
    if (line) {
      if (line.classList.contains('step-1')) this.hoveredQueryStep.set(1);
      else if (line.classList.contains('step-2')) this.hoveredQueryStep.set(2);
      else if (line.classList.contains('step-3')) this.hoveredQueryStep.set(3);
    } else {
      this.hoveredQueryStep.set(null);
    }
  }

  onProjectionCodeHover(event: MouseEvent): void {
    const target = event.target as HTMLElement;
    const line = target.closest('.step-line');
    if (line) {
      if (line.classList.contains('step-1')) this.hoveredProjectionStep.set(1);
      else if (line.classList.contains('step-2')) this.hoveredProjectionStep.set(2);
      else if (line.classList.contains('step-3')) this.hoveredProjectionStep.set(3);
    } else {
      this.hoveredProjectionStep.set(null);
    }
  }

  private async highlightCodeSamples(): Promise<void> {
    const [
      installHtml,
      setupHtml,
      bindingHtml,
      commandHtml,
      commandBindingHtml,
      queryHtml,
      queryBindingHtml,
      projectionHtml,
      projectionBindingHtml,
      completeExampleHtml
    ] = await Promise.all([
      this.codeHighlighter.highlight(this.installCodeSample, {
        language: 'bash'
      }),
      this.codeHighlighter.highlight(this.setupCodeSample, {
        language: 'csharp',
        stepHighlights: [
          { step: 1, lines: [3, 4, 5, 6, 7, 8] },      // Setup storage client
          { step: 2, lines: [10, 11, 12] },            // Configure Blob Event Store
          { step: 3, lines: [14, 15] },                // Register generated code
          { step: 4, lines: [17, 18] }                 // Add Minimal API bindings
        ]
      }),
      this.codeHighlighter.highlight(this.bindingCodeSample, {
        language: 'csharp',
        stepHighlights: [
          { step: 1, lines: [1, 2, 3, 4, 5, 6, 7, 8] },       // [EventStream] basic
          { step: 2, lines: [10, 11, 12, 13, 14, 15, 16, 17] }, // [EventStream("param")]
          { step: 3, lines: [19, 20, 21, 22, 23, 24, 25, 26] }, // [EventStream(CreateIfNotExists)]
          { step: 4, lines: [28, 29, 30, 31, 32, 34, 35, 36, 37, 38, 39] } // [Projection] variants
        ]
      }),
      this.codeHighlighter.highlight(this.commandCodeSample, {
        language: 'csharp',
        highlightLines: [6, 7, 10, 11, 12, 13, 14, 24, 30]
      }),
      this.codeHighlighter.highlight(this.commandBindingCodeSample, {
        language: 'csharp',
        stepHighlights: [
          { step: 1, lines: [1, 2, 3, 4] },            // Bind the aggregate
          { step: 2, lines: [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15] }, // Execute domain commands
          { step: 3, lines: [16] }                     // Update projections
        ]
      }),
      this.codeHighlighter.highlight(this.queryCodeSample, {
        language: 'csharp',
        highlightLines: [5, 20, 23]
      }),
      this.codeHighlighter.highlight(this.queryBindingCodeSample, {
        language: 'csharp',
        stepHighlights: [
          { step: 1, lines: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14] }, // Query from aggregate
          { step: 2, lines: [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29] }, // Query from projection
          { step: 3, lines: [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42] } // Routed projections
        ]
      }),
      this.codeHighlighter.highlight(this.projectionCodeSample, {
        language: 'csharp',
        highlightLines: [10, 11, 19, 20, 21, 31, 32, 33, 34]
      }),
      this.codeHighlighter.highlight(this.projectionBindingCodeSample, {
        language: 'csharp',
        stepHighlights: [
          { step: 1, lines: [1, 2, 3, 4, 5, 6, 7, 8, 9] },   // Single projection update
          { step: 2, lines: [11, 12, 13, 14, 15, 16, 17, 18, 19] }, // Multiple projections
          { step: 3, lines: [21, 22, 23, 24, 25, 26, 27, 28, 29] }  // Routed projection updates
        ]
      }),
      this.codeHighlighter.highlight(this.completeExampleCodeSample, {
        language: 'csharp',
        highlightLines: [17, 23, 27, 34, 40, 47, 52, 56]
      })
    ]);

    this.installCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(installHtml));
    this.setupCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(setupHtml));
    this.bindingCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(bindingHtml));
    this.commandCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(commandHtml));
    this.commandBindingCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(commandBindingHtml));
    this.queryCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(queryHtml));
    this.queryBindingCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(queryBindingHtml));
    this.projectionCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(projectionHtml));
    this.projectionBindingCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(projectionBindingHtml));
    this.completeExampleCodeHtml.set(this.sanitizer.bypassSecurityTrustHtml(completeExampleHtml));
  }
}
