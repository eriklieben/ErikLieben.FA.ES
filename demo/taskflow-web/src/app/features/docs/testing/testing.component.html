<div class="page-layout">
      <div class="main-content">
        <div class="header">
          <h1>Testing</h1>
          <p class="subtitle">In-memory event store and utilities for testing your domain</p>
        </div>

        <!-- Overview Section -->
        <section id="overview" class="doc-section">
          <h2><mat-icon>info</mat-icon> Testing Event-Sourced Systems</h2>
          <p class="section-description">
            The <code>ErikLieben.FA.ES.Testing</code> package provides in-memory implementations of all storage
            interfaces, making it easy to test your aggregates and projections without external dependencies.
            Tests run fast, are deterministic, and can easily verify event sequences.
          </p>

          <div class="benefit-grid">
            <div class="benefit-card">
              <mat-icon>speed</mat-icon>
              <h3>Fast</h3>
              <p>In-memory storage means tests run in milliseconds without I/O.</p>
            </div>
            <div class="benefit-card">
              <mat-icon>replay</mat-icon>
              <h3>Deterministic</h3>
              <p>No external dependencies means consistent, reproducible results.</p>
            </div>
            <div class="benefit-card">
              <mat-icon>visibility</mat-icon>
              <h3>Observable</h3>
              <p>Inspect events, verify sequences, and assert on state changes.</p>
            </div>
            <div class="benefit-card">
              <mat-icon>layers_clear</mat-icon>
              <h3>Isolated</h3>
              <p>Each test gets its own clean event store instance.</p>
            </div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Installation Section -->
        <section id="installation" class="doc-section">
          <h2><mat-icon>download</mat-icon> Installation</h2>
          <p class="section-description">
            Add the testing package to your test project:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>terminal</mat-icon>
              <span>Install Testing Package</span>
            </div>
            <div class="shiki-container" [innerHTML]="installCodeHtml()"></div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- TestSetup Section -->
        <section id="test-setup" class="doc-section">
          <h2><mat-icon>settings</mat-icon> TestSetup Helper</h2>
          <p class="section-description">
            The <code>TestSetup</code> class provides a convenient way to create a complete testing environment
            with all necessary in-memory implementations:
          </p>

          <h3>Recommended: Generic Methods</h3>
          <p>
            When your aggregates implement <code>ITestableAggregate</code> (generated by the CLI), use the generic methods
            for type-safe, refactoring-friendly code with no magic strings:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>star</mat-icon>
              <span>Recommended Approach</span>
            </div>
            <div class="shiki-container" [innerHTML]="testSetupCodeHtml()"></div>
          </div>

          <h3>Alternative: String-Based Methods</h3>
          <p>
            Use the string-based approach when working with:
          </p>
          <ul class="use-case-list">
            <li><strong>Legacy aggregates</strong> that don't implement <code>ITestableAggregate</code></li>
            <li><strong>Third-party aggregates</strong> where you can't modify the source</li>
            <li><strong>Dynamic scenarios</strong> where the object name is determined at runtime</li>
          </ul>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>history</mat-icon>
              <span>Alternative Approach</span>
            </div>
            <div class="shiki-container" [innerHTML]="testSetupAlternativeCodeHtml()"></div>
          </div>

          <h3>What TestSetup Provides</h3>
          <div class="component-list">
            <div class="component-item">
              <mat-icon>storage</mat-icon>
              <div>
                <strong>InMemoryEventStreamFactory</strong>
                <span>Creates and retrieves event streams backed by in-memory storage.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>data_object</mat-icon>
              <div>
                <strong>InMemoryDataStore</strong>
                <span>Stores event documents without persistence.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>photo_camera</mat-icon>
              <div>
                <strong>InMemorySnapShotStore</strong>
                <span>Handles snapshot creation and retrieval.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>verified</mat-icon>
              <div>
                <strong>TestContext.Assert</strong>
                <span>Fluent assertions for verifying events and state.</span>
              </div>
            </div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Testing Aggregates Section -->
        <section id="aggregates" class="doc-section">
          <h2><mat-icon>category</mat-icon> Testing Aggregates</h2>
          <p class="section-description">
            Test your aggregate's command methods and verify the resulting events. The testing library provides
            two approaches: a simple direct approach and a fluent builder pattern.
          </p>

          <h3>Simple Approach</h3>
          <p>
            Use the <code>TestContext</code> directly for straightforward tests:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>code</mat-icon>
              <span>Direct TestContext Usage</span>
            </div>
            <div class="shiki-container" [innerHTML]="aggregateTestCodeHtml()"></div>
          </div>

          <h3>Fluent Builder Pattern - Two Options</h3>
          <p>
            The <code>AggregateTestBuilder</code> provides a fluent Given-When-Then API that's fully AOT-compatible.
            There are <strong>two patterns</strong> depending on whether your aggregate implements <code>ITestableAggregate</code>.
          </p>

          <h4>Pattern 1: ITestableAggregate (Recommended)</h4>
          <p>
            When your aggregate implements <code>ITestableAggregate&lt;TSelf&gt;</code>, use the simpler syntax.
            The CLI automatically generates the <code>ObjectName</code> and <code>Create</code> static members for you:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>star</mat-icon>
              <span>Pattern 1: ITestableAggregate</span>
            </div>
            <div class="shiki-container" [innerHTML]="pattern1CodeHtml()"></div>
          </div>

          <h4>Pattern 2: Explicit Factory</h4>
          <p>
            Use this when your aggregate doesn't implement <code>ITestableAggregate</code>,
            you need custom initialization, or want to use a different object name for testing:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>build</mat-icon>
              <span>Pattern 2: Explicit Factory</span>
            </div>
            <div class="shiki-container" [innerHTML]="pattern2CodeHtml()"></div>
          </div>

          <div class="info-callout">
            <mat-icon>memory</mat-icon>
            <div>
              <strong>AOT Compatibility</strong>
              <p>Both patterns use C# 11 static abstract interface members instead of reflection,
              making them fully compatible with Native AOT compilation and trimming.</p>
            </div>
          </div>

          <h3>ITestableAggregate Interface</h3>
          <p>To use Pattern 1, implement <code>ITestableAggregate&lt;TSelf&gt;</code> on your aggregate:</p>
          <div class="component-list">
            <div class="component-item">
              <mat-icon>label</mat-icon>
              <div>
                <strong>static string ObjectName</strong>
                <span>The logical name for the aggregate's event stream (e.g., "order", "project").</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>add_circle</mat-icon>
              <div>
                <strong>static TSelf Create(IEventStream stream)</strong>
                <span>Factory method to create an instance from an event stream.</span>
              </div>
            </div>
          </div>

          <h3>Builder Features</h3>
          <div class="component-list">
            <div class="component-item">
              <mat-icon>auto_awesome</mat-icon>
              <div>
                <strong>Zero-Boilerplate Creation</strong>
                <span>With ITestableAggregate: <code>.For&lt;Order&gt;(id, context)</code> - no factory needed.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>layers</mat-icon>
              <div>
                <strong>Given-When-Then Flow</strong>
                <span>Set up state with <code>.Given(events)</code>, execute with <code>.When(command)</code>, verify with <code>.Then(assertions)</code>.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>link</mat-icon>
              <div>
                <strong>Fluent Chaining</strong>
                <span>Chain operations for readable, expressive test code.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>settings</mat-icon>
              <div>
                <strong>Custom Factory (Pattern 2)</strong>
                <span>Pass a factory delegate for custom initialization: <code>.For("name", id, ctx, s =&gt; new T(s, dep))</code></span>
              </div>
            </div>
          </div>

          <h3>Fluent Assertions</h3>
          <p>
            Use the fluent assertion API to verify events and state:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>verified</mat-icon>
              <span>Using Assertions</span>
            </div>
            <div class="shiki-container" [innerHTML]="assertionsCodeHtml()"></div>
          </div>

          <h4>Available Assertion Methods</h4>
          <div class="assertion-table">
            <div class="assertion-row header">
              <span class="assertion-method">Method</span>
              <span class="assertion-desc">Description</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>ShouldHaveObject&lt;T&gt;(id)</code></span>
              <span class="assertion-desc">Preferred: Type-safe, uses ITestableAggregate.ObjectName.</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>ShouldHaveObject(name, id)</code></span>
              <span class="assertion-desc">Alternative: String-based, for aggregates without ITestableAggregate.</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>.WithEventCount(n)</code></span>
              <span class="assertion-desc">Asserts the exact number of events in the stream.</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>.WithEventAtLastPosition(e)</code></span>
              <span class="assertion-desc">Verifies the last event matches the expected event.</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>.WithEventAtPosition(n, e)</code></span>
              <span class="assertion-desc">Verifies the event at position n matches.</span>
            </div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Testing Projections Section -->
        <section id="projections" class="doc-section">
          <h2><mat-icon>view_quilt</mat-icon> Testing Projections</h2>
          <p class="section-description">
            Projections build read models by processing events from one or more aggregates.
            Test them by setting up events and verifying the resulting state.
          </p>

          <h3>Simple Approach</h3>
          <p>
            Use <code>TestContext</code> to set up events across multiple aggregates, then verify the projection state:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>code</mat-icon>
              <span>Direct TestContext Usage</span>
            </div>
            <div class="shiki-container" [innerHTML]="projectionTestCodeHtml()"></div>
          </div>

          <h3>Fluent Builder Pattern - Two Options</h3>
          <p>
            The <code>ProjectionTestBuilder</code> provides a fluent Given-When-Then API for projections.
            There are <strong>two patterns</strong> depending on whether your projection implements <code>ITestableProjection</code>.
          </p>

          <h4>Pattern 1: ITestableProjection (Recommended)</h4>
          <p>
            When your projection implements <code>ITestableProjection&lt;TSelf&gt;</code>, use the simpler syntax.
            The CLI automatically generates the <code>Create</code> static factory method for you:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>star</mat-icon>
              <span>Pattern 1: ITestableProjection</span>
            </div>
            <div class="shiki-container" [innerHTML]="projectionPattern1CodeHtml()"></div>
          </div>

          <h4>Pattern 2: Explicit Factory</h4>
          <p>
            Use this when your projection doesn't implement <code>ITestableProjection</code>,
            you need custom initialization, or want to inject mock dependencies:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>build</mat-icon>
              <span>Pattern 2: Explicit Factory</span>
            </div>
            <div class="shiki-container" [innerHTML]="projectionPattern2CodeHtml()"></div>
          </div>

          <h3>Builder Features</h3>
          <div class="component-list">
            <div class="component-item">
              <mat-icon>category</mat-icon>
              <div>
                <strong>Type-Safe Aggregate References</strong>
                <span>Use <code>.Given&lt;Project&gt;("id", events...)</code> for compile-time safety.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>layers</mat-icon>
              <div>
                <strong>Multi-Aggregate Setup</strong>
                <span>Chain multiple <code>.Given&lt;T&gt;</code> calls to set up events from different aggregates.</span>
              </div>
            </div>
            <div class="component-item">
              <mat-icon>sync</mat-icon>
              <div>
                <strong>Explicit Update Trigger</strong>
                <span><code>.WhenProjectionUpdates()</code> clearly marks when the projection processes events.</span>
              </div>
            </div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Time Testing Section -->
        <section id="time-testing" class="doc-section">
          <h2><mat-icon>schedule</mat-icon> Time Testing</h2>
          <p class="section-description">
            The <code>TestClock</code> extends .NET's <code>TimeProvider</code> abstract class, allowing you to
            control time in tests. Use it anywhere <code>TimeProvider</code> is expected for testing
            time-dependent business logic like deadlines, expiration, and scheduled events.
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>code</mat-icon>
              <span>Time Manipulation in Tests</span>
            </div>
            <div class="shiki-container" [innerHTML]="timeTestingCodeHtml()"></div>
          </div>

          <h3>TestClock Methods</h3>
          <div class="assertion-table">
            <div class="assertion-row header">
              <span class="assertion-method">Method</span>
              <span class="assertion-desc">Description</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>SetUtcNow(DateTimeOffset)</code></span>
              <span class="assertion-desc">Sets the clock to a specific UTC time (TimeProvider compatible).</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>Advance(TimeSpan)</code></span>
              <span class="assertion-desc">Moves time forward by the specified duration (TimeProvider compatible).</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>GetUtcNow()</code></span>
              <span class="assertion-desc">Returns current UTC time (TimeProvider override).</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>Freeze()</code></span>
              <span class="assertion-desc">Stops time from advancing, useful for deterministic tests.</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>Unfreeze()</code></span>
              <span class="assertion-desc">Resumes normal time progression.</span>
            </div>
          </div>

          <div class="info-callout">
            <mat-icon>integration_instructions</mat-icon>
            <div>
              <strong>TimeProvider Integration</strong>
              <p><code>TestClock</code> extends <code>TimeProvider</code>, so you can inject it into any service
              that depends on <code>TimeProvider</code> for time operations.</p>
            </div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Test Patterns Section -->
        <section id="patterns" class="doc-section">
          <h2><mat-icon>pattern</mat-icon> Test Patterns</h2>
          <p class="section-description">
            Common patterns for testing event-sourced systems:
          </p>

          <h3>Given Events Pattern</h3>
          <div class="code-block">
            <div class="code-header">
              <mat-icon>code</mat-icon>
              <span>Setup Existing Events</span>
            </div>
            <div class="shiki-container" [innerHTML]="givenEventsCodeHtml()"></div>
          </div>

          <h3>Verify Business Rules Pattern</h3>
          <div class="code-block">
            <div class="code-header">
              <mat-icon>code</mat-icon>
              <span>Test Invariant Enforcement</span>
            </div>
            <div class="shiki-container" [innerHTML]="invariantTestCodeHtml()"></div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Performance Testing Section -->
        <section id="performance" class="doc-section">
          <h2><mat-icon>speed</mat-icon> Performance Testing</h2>
          <p class="section-description">
            Lightweight performance measurement utilities for testing event stream operations.
            No external dependencies required.
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>code</mat-icon>
              <span>Performance Tests</span>
            </div>
            <div class="shiki-container" [innerHTML]="performanceCodeHtml()"></div>
          </div>

          <h3>Performance Assertions</h3>
          <div class="assertion-table">
            <div class="assertion-row header">
              <span class="assertion-method">Assertion</span>
              <span class="assertion-desc">Description</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>ShouldCompleteWithin(TimeSpan)</code></span>
              <span class="assertion-desc">Asserts operation completes within time limit.</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>ShouldHaveThroughputOf(ops)</code></span>
              <span class="assertion-desc">Asserts minimum operations per second.</span>
            </div>
            <div class="assertion-row">
              <span class="assertion-method"><code>ShouldNotCauseGen2Collection()</code></span>
              <span class="assertion-desc">Ensures no Gen2 garbage collections occurred.</span>
            </div>
          </div>

          <div class="info-callout">
            <mat-icon>info</mat-icon>
            <div>
              <strong>Note on Performance Testing</strong>
              <p>These utilities are for simple performance checks during development.
              For comprehensive benchmarking with statistical analysis, consider BenchmarkDotNet.</p>
            </div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Best Practices Section -->
        <section id="best-practices" class="doc-section">
          <h2><mat-icon>verified</mat-icon> Best Practices</h2>
          <p class="section-description">
            Follow these guidelines for effective testing:
          </p>

          <div class="practice-grid">
            <div class="practice-card do">
              <div class="practice-header">
                <mat-icon>check_circle</mat-icon>
                <h3>Do</h3>
              </div>
              <ul>
                <li>Test one behavior per test method</li>
                <li>Use descriptive test names that explain the scenario</li>
                <li>Verify both happy paths and error cases</li>
                <li>Test business rules through aggregate commands</li>
                <li>Set up initial state with events, not by setting properties</li>
                <li>Assert on events emitted, not internal state</li>
              </ul>
            </div>
            <div class="practice-card dont">
              <div class="practice-header">
                <mat-icon>cancel</mat-icon>
                <h3>Don't</h3>
              </div>
              <ul>
                <li>Test implementation details of When methods</li>
                <li>Set aggregate properties directly in tests</li>
                <li>Use real storage in unit tests</li>
                <li>Test multiple unrelated behaviors in one test</li>
                <li>Skip testing error conditions</li>
                <li>Rely on test execution order</li>
              </ul>
            </div>
          </div>
        </section>

        <mat-divider></mat-divider>

        <!-- Complete Example Section -->
        <section id="complete-example" class="doc-section">
          <h2><mat-icon>integration_instructions</mat-icon> Complete Test Class</h2>
          <p class="section-description">
            A complete example showing a well-structured test class:
          </p>

          <div class="code-block">
            <div class="code-header">
              <mat-icon>code</mat-icon>
              <span>OrderAggregateTests.cs</span>
            </div>
            <div class="shiki-container" [innerHTML]="completeExampleCodeHtml()"></div>
          </div>
        </section>
      </div>

      <!-- Right Navigation -->
      <nav class="doc-nav">
        <div class="nav-header">On this page</div>
        <ul class="nav-list">
          @for (item of navItems; track item.id) {
            <li>
              <a
                [href]="'#' + item.id"
                [class.active]="activeSection() === item.id"
                (click)="scrollToSection($event, item.id)">
                <mat-icon>{{ item.icon }}</mat-icon>
                {{ item.label }}
              </a>
            </li>
          }
        </ul>
      </nav>
    </div>