# Repository Generation Proposal

## Overview

Currently, the CLI generates `*Factory` classes for each aggregate to handle object creation. This proposal introduces **Repository pattern generation** alongside the existing Factory pattern to provide query capabilities, specifically for retrieving object IDs with continuation token-based pagination support.

**Repository generation will be mandatory** - all aggregates will automatically get a corresponding Repository generated by the CLI.

## Motivation

### Problem
- Factories are responsible for **creation**, not **querying**
- No standardized way to retrieve lists of object IDs for a given aggregate type
- Need to handle potentially thousands of aggregate instances efficiently (pagination required)
- Consumers currently must interact directly with `IObjectDocumentFactory` which leaks infrastructure concerns

### Solution
Generate Repository classes that provide:
- Read-only query operations for aggregates
- Continuation token-based pagination for efficient traversal of large datasets
- Abstraction over the underlying storage infrastructure
- Clean separation from Factory (creation) concerns

## Current State

### Generated Factory (Existing)

Currently, the CLI generates a single `*.Generated.cs` file per aggregate containing:
- The aggregate partial class
- The aggregate interface (`IWorkItem`, `IProject`)
- The snapshot record
- The factory interface (`IWorkItemFactory`, `IProjectFactory`)
- The factory implementation

**Example: `WorkItem.Generated.cs`**

```csharp
// Lines 16-127: Aggregate class
public partial class WorkItem : Aggregate, IBase, IWorkItem
{
    public override void Fold(IEvent @event) { ... }
    protected override void GeneratedSetup() { ... }
    public override void ProcessSnapshot(object snapshot) { ... }
}

// Lines 130-145: Aggregate interface
public interface IWorkItem
{
    public Guid WorkItemId { get; }
    public String? ProjectId { get; }
    // ... other properties
}

// Lines 148-163: Snapshot record
public record WorkItemSnapshot : IWorkItem { ... }

// Lines 192-194: Factory interface
public partial interface IWorkItemFactory : IAggregateFactory<WorkItem, Guid> { }

// Lines 197-308: Factory implementation
public partial class WorkItemFactory : IWorkItemFactory
{
    // ✅ CREATION methods (proper Factory pattern - these stay)
    public WorkItem Create(IEventStream eventStream) { ... }
    public WorkItem Create(IObjectDocument document) { ... }
    public async Task<WorkItem> CreateAsync(Guid id) { ... }
    protected async Task<WorkItem> CreateAsync<T>(Guid id, T firstEvent) { ... }

    // ❌ QUERY methods (violate Factory pattern - these will be marked obsolete)
    public async Task<WorkItem> GetAsync(Guid id) { ... }
    public async Task<(WorkItem, IObjectDocument)> GetWithDocumentAsync(Guid id) { ... }
    public async Task<WorkItem?> GetFirstByDocumentTag(string tag) { ... }
    public async Task<IEnumerable<WorkItem>> GetAllByDocumentTag(string tag) { ... }
}
```

**Problem**: The Factory currently has both **creation** and **query** responsibilities, violating the Single Responsibility Principle.

## Proposed Solution

### Generated Repository Interface

```csharp
public interface IProjectRepository
{
    /// <summary>
    /// Gets a paginated list of all Project object IDs using continuation tokens.
    /// </summary>
    /// <param name="continuationToken">Optional continuation token from previous page. Null for first page.</param>
    /// <param name="pageSize">Number of items to return per page. Default: 100, Max: 1000.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A paged result containing object IDs and a continuation token for the next page.</returns>
    Task<PagedResult<string>> GetObjectIdsAsync(
        string? continuationToken = null,
        int pageSize = 100,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a single aggregate by ID.
    /// Replaces: ProjectFactory.GetAsync(Guid id)
    /// </summary>
    Task<Project?> GetByIdAsync(
        Guid id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a single aggregate by ID along with its document.
    /// Replaces: ProjectFactory.GetWithDocumentAsync(Guid id)
    /// </summary>
    Task<(Project?, IObjectDocument?)> GetByIdWithDocumentAsync(
        Guid id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the first aggregate with the specified document tag.
    /// Replaces: ProjectFactory.GetFirstByDocumentTag(string tag)
    /// </summary>
    Task<Project?> GetFirstByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all aggregates with the specified document tag.
    /// Replaces: ProjectFactory.GetAllByDocumentTag(string tag)
    /// </summary>
    Task<IEnumerable<Project>> GetAllByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an aggregate with the given ID exists.
    /// </summary>
    Task<bool> ExistsAsync(
        Guid id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of aggregates.
    /// Note: This may be expensive for large datasets as it requires enumerating all items.
    /// </summary>
    Task<long> CountAsync(CancellationToken cancellationToken = default);
}
```

### Generated Repository Implementation

```csharp
public partial class ProjectRepository : IProjectRepository
{
    private readonly IProjectFactory projectFactory;
    private readonly IObjectDocumentFactory objectDocumentFactory;
    private readonly IObjectIdProvider objectIdProvider;

    public static string ObjectName => "project";

    public ProjectRepository(
        IProjectFactory projectFactory,
        IObjectDocumentFactory objectDocumentFactory,
        IObjectIdProvider objectIdProvider)
    {
        ArgumentNullException.ThrowIfNull(projectFactory);
        ArgumentNullException.ThrowIfNull(objectDocumentFactory);
        ArgumentNullException.ThrowIfNull(objectIdProvider);

        this.projectFactory = projectFactory;
        this.objectDocumentFactory = objectDocumentFactory;
        this.objectIdProvider = objectIdProvider;
    }

    public async Task<PagedResult<string>> GetObjectIdsAsync(
        string? continuationToken = null,
        int pageSize = 100,
        CancellationToken cancellationToken = default)
    {
        ArgumentOutOfRangeException.ThrowIfLessThan(pageSize, 1);
        ArgumentOutOfRangeException.ThrowIfGreaterThan(pageSize, 1000);

        return await objectIdProvider.GetObjectIdsAsync(
            ObjectName,
            continuationToken,
            pageSize,
            cancellationToken);
    }

    public async Task<Project?> GetByIdAsync(
        Guid id,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var document = await objectDocumentFactory.GetAsync(ObjectName, id.ToString());
            var obj = projectFactory.Create(document);
            await obj.Fold();
            return obj;
        }
        catch (DocumentNotFoundException)
        {
            return null;
        }
    }

    public async Task<(Project?, IObjectDocument?)> GetByIdWithDocumentAsync(
        Guid id,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var document = await objectDocumentFactory.GetAsync(ObjectName, id.ToString());
            var obj = projectFactory.Create(document);
            await obj.Fold();
            return (obj, document);
        }
        catch (DocumentNotFoundException)
        {
            return (null, null);
        }
    }

    public async Task<Project?> GetFirstByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(tag);

        var document = await objectDocumentFactory.GetFirstByObjectDocumentTag(ObjectName, tag);
        if (document == null)
        {
            return null;
        }

        var obj = projectFactory.Create(document);
        await obj.Fold();
        return obj;
    }

    public async Task<IEnumerable<Project>> GetAllByDocumentTagAsync(
        string tag,
        CancellationToken cancellationToken = default)
    {
        ArgumentException.ThrowIfNullOrEmpty(tag);

        var documents = await objectDocumentFactory.GetByObjectDocumentTag(ObjectName, tag);
        var items = new List<Project>();

        foreach (var document in documents)
        {
            var obj = projectFactory.Create(document);
            await obj.Fold();
            items.Add(obj);
        }

        return items;
    }

    public async Task<bool> ExistsAsync(
        Guid id,
        CancellationToken cancellationToken = default)
    {
        return await objectIdProvider.ExistsAsync(
            ObjectName,
            id.ToString(),
            cancellationToken);
    }

    public async Task<long> CountAsync(CancellationToken cancellationToken = default)
    {
        return await objectIdProvider.CountAsync(ObjectName, cancellationToken);
    }
}
```

### Supporting Infrastructure

#### PagedResult Model
```csharp
/// <summary>
/// Represents a page of results with continuation token support for efficient pagination.
/// </summary>
public class PagedResult<T>
{
    /// <summary>
    /// The items in the current page.
    /// </summary>
    public IReadOnlyList<T> Items { get; init; } = Array.Empty<T>();

    /// <summary>
    /// The number of items in this page.
    /// </summary>
    public int PageSize { get; init; }

    /// <summary>
    /// Continuation token for retrieving the next page. Null if no more pages.
    /// </summary>
    public string? ContinuationToken { get; init; }

    /// <summary>
    /// Indicates whether there are more pages available.
    /// </summary>
    public bool HasNextPage => !string.IsNullOrEmpty(ContinuationToken);
}
```

#### IObjectIdProvider Interface (New Infrastructure)
```csharp
/// <summary>
/// Provides object ID enumeration and querying capabilities across storage providers.
/// </summary>
public interface IObjectIdProvider
{
    /// <summary>
    /// Gets a page of object IDs for the specified object type.
    /// </summary>
    /// <param name="objectName">The object type name (e.g., "project", "workItem").</param>
    /// <param name="continuationToken">Optional continuation token from previous page.</param>
    /// <param name="pageSize">Number of items to return.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>A paged result with items and continuation token.</returns>
    Task<PagedResult<string>> GetObjectIdsAsync(
        string objectName,
        string? continuationToken,
        int pageSize,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an object document exists for the given ID.
    /// </summary>
    Task<bool> ExistsAsync(
        string objectName,
        string objectId,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of objects for the given type.
    /// Warning: This may be expensive for large datasets.
    /// </summary>
    Task<long> CountAsync(
        string objectName,
        CancellationToken cancellationToken = default);
}
```

#### Blob Storage Implementation
```csharp
public class BlobObjectIdProvider : IObjectIdProvider
{
    private readonly BlobContainerClient containerClient;

    public BlobObjectIdProvider(BlobContainerClient containerClient)
    {
        ArgumentNullException.ThrowIfNull(containerClient);
        this.containerClient = containerClient;
    }

    public async Task<PagedResult<string>> GetObjectIdsAsync(
        string objectName,
        string? continuationToken,
        int pageSize,
        CancellationToken cancellationToken = default)
    {
        var prefix = $"{objectName}/";
        var items = new List<string>();
        string? nextContinuationToken = null;

        // Use Azure Blob Storage's native pagination with continuation tokens
        var resultSegment = containerClient
            .GetBlobsAsync(prefix: prefix, cancellationToken: cancellationToken)
            .AsPages(continuationToken, pageSize);

        // Get only the first page (we only need one page per call)
        await foreach (var page in resultSegment)
        {
            var objectIds = page.Values
                .Select(b => ExtractObjectId(b.Name, objectName))
                .Where(id => !string.IsNullOrEmpty(id))
                .Distinct()
                .ToList();

            items.AddRange(objectIds);
            nextContinuationToken = page.ContinuationToken;
            break; // Only process first page
        }

        return new PagedResult<string>
        {
            Items = items,
            PageSize = pageSize,
            ContinuationToken = nextContinuationToken
        };
    }

    public async Task<bool> ExistsAsync(
        string objectName,
        string objectId,
        CancellationToken cancellationToken = default)
    {
        var blobPath = $"{objectName}/{objectId}/stream.json";
        var blobClient = containerClient.GetBlobClient(blobPath);
        return await blobClient.ExistsAsync(cancellationToken);
    }

    public async Task<long> CountAsync(
        string objectName,
        CancellationToken cancellationToken = default)
    {
        var prefix = $"{objectName}/";
        var objectIds = new HashSet<string>();

        await foreach (var blob in containerClient.GetBlobsAsync(
            prefix: prefix,
            cancellationToken: cancellationToken))
        {
            var objectId = ExtractObjectId(blob.Name, objectName);
            if (!string.IsNullOrEmpty(objectId))
            {
                objectIds.Add(objectId);
            }
        }

        return objectIds.Count;
    }

    private string ExtractObjectId(string blobPath, string objectName)
    {
        // Extract from path like "project/12345-guid/stream.json"
        // Format: {objectName}/{objectId}/stream.json
        var prefix = $"{objectName}/";
        if (!blobPath.StartsWith(prefix))
        {
            return string.Empty;
        }

        var remainder = blobPath.Substring(prefix.Length);
        var parts = remainder.Split('/');
        return parts.Length > 0 ? parts[0] : string.Empty;
    }
}
```

## Usage Examples

### Retrieving Paginated Object IDs
```csharp
public class ProjectService
{
    private readonly IProjectRepository projectRepository;

    public async Task<PagedResult<string>> GetFirstPageOfProjectIdsAsync(int pageSize = 100)
    {
        // Get first page by passing null continuation token
        return await projectRepository.GetObjectIdsAsync(
            continuationToken: null,
            pageSize: pageSize);
    }

    public async Task<List<Project>> GetAllProjectsAsync()
    {
        var allProjects = new List<Project>();
        string? continuationToken = null;
        const int pageSize = 100;

        do
        {
            var result = await projectRepository.GetObjectIdsAsync(
                continuationToken,
                pageSize);

            foreach (var objectId in result.Items)
            {
                var project = await projectRepository.GetByIdAsync(objectId);
                if (project != null)
                {
                    allProjects.Add(project);
                }
            }

            continuationToken = result.ContinuationToken;
        }
        while (!string.IsNullOrEmpty(continuationToken));

        return allProjects;
    }

    public async Task<PagedResult<string>> GetNextPageAsync(string continuationToken, int pageSize = 100)
    {
        // Get next page using continuation token from previous call
        return await projectRepository.GetObjectIdsAsync(continuationToken, pageSize);
    }
}
```

### API Endpoint Example
```csharp
[HttpGet("projects")]
public async Task<ActionResult<PagedResult<string>>> GetProjects(
    [FromQuery] string? continuationToken = null,
    [FromQuery] int pageSize = 50)
{
    var result = await projectRepository.GetObjectIdsAsync(continuationToken, pageSize);
    return Ok(result);
}

[HttpGet("projects/{id}")]
public async Task<ActionResult<ProjectDto>> GetProject(string id)
{
    var project = await projectRepository.GetByIdAsync(id);
    if (project == null)
    {
        return NotFound();
    }

    return Ok(MapToDto(project));
}

[HttpGet("projects/{id}/exists")]
public async Task<ActionResult<bool>> ProjectExists(string id)
{
    var exists = await projectRepository.ExistsAsync(id);
    return Ok(exists);
}
```

## CLI Generation

### Command
```bash
# Repositories are ALWAYS generated alongside Factories
dotnet faes generate aggregate Project
```

### Generated Files

**Current Structure:**
```
src/TaskFlow.Domain/
├── Aggregates/
│   ├── WorkItem.cs                # User-defined
│   └── WorkItem.Generated.cs      # Generated (aggregate + factory + interface)
```

**New Structure (with Repository):**
```
src/TaskFlow.Domain/
├── Aggregates/
│   ├── WorkItem.cs                # User-defined
│   └── WorkItem.Generated.cs      # Generated (aggregate + factory + repository + interfaces)
```

**Updated Contents of `WorkItem.Generated.cs`:**
```csharp
namespace TaskFlow.Domain.Aggregates;

// Lines 16-127: Aggregate class (existing)
public partial class WorkItem : Aggregate, IBase, IWorkItem { ... }

// Lines 130-145: Aggregate interface (existing)
public interface IWorkItem { ... }

// Lines 148-163: Snapshot record (existing)
public record WorkItemSnapshot : IWorkItem { ... }

// Lines 192-194: Factory interface (existing)
public partial interface IWorkItemFactory : IAggregateFactory<WorkItem, Guid> { }

// Lines 197-308: Factory implementation (existing, with obsolete attributes added)
public partial class WorkItemFactory : IWorkItemFactory { ... }

// NEW: Repository interface
//<auto-generated />
public partial interface IWorkItemRepository
{
    Task<PagedResult<string>> GetObjectIdsAsync(...);
    Task<WorkItem?> GetByIdAsync(...);
    Task<(WorkItem?, IObjectDocument?)> GetByIdWithDocumentAsync(...);
    Task<WorkItem?> GetFirstByDocumentTagAsync(...);
    Task<IEnumerable<WorkItem>> GetAllByDocumentTagAsync(...);
    Task<bool> ExistsAsync(...);
    Task<long> CountAsync(...);
}

// NEW: Repository implementation
//<auto-generated />
public partial class WorkItemRepository : IWorkItemRepository
{
    // ... implementation
}
```

**Key Point**: Everything stays in the **same `.Generated.cs` file** - no separate repository file.

### Service Registration (Auto-generated)
```csharp
// In TaskFlow.DomainExtensions.Generated.cs
public static IServiceCollection AddTaskFlowDomain(
    this IServiceCollection services)
{
    // Existing Factory registrations
    services.AddScoped<IProjectFactory, ProjectFactory>();
    services.AddScoped<IWorkItemFactory, WorkItemFactory>();

    // NEW: Repository registrations (automatically generated)
    services.AddScoped<IProjectRepository, ProjectRepository>();
    services.AddScoped<IWorkItemRepository, WorkItemRepository>();

    return services;
}
```

## Backward Compatibility & Factory Changes

### Factory Methods Marked as Obsolete

Currently, Factory classes have **query methods** that violate the Factory pattern (Factory should only create, not query). These will be **marked as `[Obsolete]`** and moved to Repository:

#### Methods to Mark Obsolete in Factory:
```csharp
[Obsolete("Use IProjectRepository.GetByIdAsync instead. This method will be removed in a future version.")]
public async Task<Project> GetAsync(Guid id)

[Obsolete("Use IProjectRepository.GetByIdWithDocumentAsync instead. This method will be removed in a future version.")]
public async Task<(Project, IObjectDocument)> GetWithDocumentAsync(Guid id)

[Obsolete("Use IProjectRepository.GetFirstByDocumentTagAsync instead. This method will be removed in a future version.")]
public async Task<Project?> GetFirstByDocumentTag(string tag)

[Obsolete("Use IProjectRepository.GetAllByDocumentTagAsync instead. This method will be removed in a future version.")]
public async Task<IEnumerable<Project>> GetAllByDocumentTag(string tag)
```

#### Methods That Stay in Factory (True Creation Methods):
- `Create(IEventStream eventStream)` - ✅ Stays (creation logic)
- `Create(IObjectDocument document)` - ✅ Stays (creation logic)
- `CreateAsync(Guid id)` - ✅ Stays (get-or-create pattern for new aggregates)
- `CreateAsync<T>(Guid id, T firstEvent)` - ✅ Stays (create with initial event)

### Deprecation Timeline

**Phase 1 (Current Release):**
- Repository generation added
- Factory query methods marked `[Obsolete]` with compiler warnings
- Both Factory and Repository methods work

**Phase 2 (Next Major Version):**
- Factory query methods removed entirely
- Only Repository provides query functionality

### Migration Path for Consumers

#### Migration 1: GetAsync → GetByIdAsync
**Before (Factory - Obsolete):**
```csharp
public class ProjectService
{
    private readonly IProjectFactory projectFactory;

    public async Task<Project> LoadProjectAsync(Guid projectId)
    {
        return await projectFactory.GetAsync(projectId);  // ⚠️ Compiler warning
    }
}
```

**After (Repository):**
```csharp
public class ProjectService
{
    private readonly IProjectRepository projectRepository;

    public async Task<Project?> LoadProjectAsync(Guid projectId)
    {
        return await projectRepository.GetByIdAsync(projectId);  // ✅ Returns null if not found
    }
}
```

#### Migration 2: GetFirstByDocumentTag → GetFirstByDocumentTagAsync
**Before (Factory - Obsolete):**
```csharp
var project = await projectFactory.GetFirstByDocumentTag("owner:user123");  // ⚠️ Warning
```

**After (Repository):**
```csharp
var project = await projectRepository.GetFirstByDocumentTagAsync("owner:user123");  // ✅
```

#### Migration 3: GetAllByDocumentTag → GetAllByDocumentTagAsync
**Before (Factory - Obsolete):**
```csharp
var projects = await projectFactory.GetAllByDocumentTag("status:active");  // ⚠️ Warning
```

**After (Repository):**
```csharp
var projects = await projectRepository.GetAllByDocumentTagAsync("status:active");  // ✅
```

#### Migration 4: Direct IObjectDocumentFactory Usage
**Before (Direct infrastructure usage):**
```csharp
public class ProjectService
{
    private readonly IObjectDocumentFactory documentFactory;

    public async Task<bool> ProjectExistsAsync(Guid projectId)
    {
        try
        {
            await documentFactory.GetAsync("project", projectId.ToString());
            return true;
        }
        catch (DocumentNotFoundException)
        {
            return false;
        }
    }
}
```

**After (Using Repository):**
```csharp
public class ProjectService
{
    private readonly IProjectRepository projectRepository;

    public async Task<bool> ProjectExistsAsync(Guid projectId)
    {
        return await projectRepository.ExistsAsync(projectId);  // ✅ Clean, type-safe
    }
}
```

This provides a cleaner, type-safe API that doesn't leak infrastructure concerns.

## Implementation Phases

### Phase 1: Core Infrastructure
1. Create `IObjectIdProvider` interface
2. Implement `BlobObjectIdProvider` for Azure Blob Storage
3. Create `PagedResult<T>` model
4. Add DI registration helpers

### Phase 2: Code Generation
1. Update CLI to generate Repository interfaces (`IProjectRepository.cs`)
2. Update CLI to generate Repository implementations (`ProjectRepository.Generated.cs`)
3. Update DI registration generation to include repositories
4. Ensure both Factory and Repository are always generated together

### Phase 3: Advanced Features (Future)
1. Add filtering support (by tags, date ranges, etc.)
2. Add sorting options
3. Add caching layer
4. Support for other storage providers (CosmosDB, SQL, etc.)

## Benefits

✅ **Separation of Concerns**: Factory creates, Repository queries
✅ **Scalability**: Built-in pagination handles large datasets
✅ **Consistency**: Standardized query interface across all aggregates
✅ **Testability**: Easy to mock `IProjectRepository` in tests
✅ **Discoverability**: Clear API for consumers
✅ **Performance**: Efficient paging prevents loading thousands of objects

## Considerations

### Pagination Strategy
- **Continuation tokens** for efficient traversal (native to Azure Blob Storage)
- Default page size: 100
- Max page size: 1000 (configurable)
- No offset/skip operations needed (more efficient)

### Continuation Token Format
- Opaque strings provided by storage provider
- Should not be parsed or manipulated by consumers
- May be URL-encoded for API usage
- Null/empty token = start from beginning

### Why Continuation Tokens Over Offset Pagination?

**Offset-based (❌ Inefficient):**
```csharp
// To get page 100 (items 9900-10000), must enumerate 9900 items first
var skip = (pageNumber - 1) * pageSize;  // 99 * 100 = 9900
var items = await blobs.Skip(9900).Take(100).ToListAsync();
```

**Continuation tokens (✅ Efficient):**
```csharp
// Storage provider resumes from exact position, no enumeration needed
var items = containerClient
    .GetBlobsAsync()
    .AsPages(continuationToken, pageSize);
```

**Performance Impact:**
- Offset pagination: O(n) for page n (gets slower as you go deeper)
- Continuation tokens: O(1) for any page (constant time)

### Caching
- Should repositories cache object IDs?
- Cache invalidation strategy?
- **Decision**: Start without caching, add later if performance metrics indicate need

### Consistency
- Object IDs reflect current storage state at query time
- Continuation tokens may become invalid if underlying data changes significantly
- No guarantee of ordering unless explicitly added
- **Decision**: Return IDs in blob name lexicographic order (Azure Blob default)

### Backward Compatibility
- Existing Factory generation remains unchanged
- Repository generation is **mandatory** (always generated)
- No breaking changes to existing APIs

## Open Questions

1. Should repositories support `SaveAsync()` or remain read-only?
   - **Recommendation**: Read-only. Use aggregates + factories for writes.

2. Should we generate a base `AggregateRepository<T>` class?
   - **Recommendation**: Yes, reduces generated code duplication.

3. Should filtering be part of the initial release?
   - **Recommendation**: No, start simple with pagination only.

4. How do we handle multi-tenancy scenarios?
   - **Recommendation**: Add optional `tenantId` parameter to methods.

## Next Steps

1. Review and approve this proposal
2. Implement Phase 1 (Core Infrastructure)
3. Update CLI code generation templates
4. Write comprehensive tests
5. Update documentation
6. Release as minor version bump

## Conclusion

Adding **mandatory** Repository generation alongside Factory generation provides a clean, standardized way to query aggregates while maintaining separation of concerns.

**Key Benefits:**
- ✅ Continuation token-based pagination for efficient, scalable traversal
- ✅ Native Azure Blob Storage integration (no inefficient skip/offset operations)
- ✅ Clean separation: Factories create, Repositories query
- ✅ Type-safe APIs that don't leak infrastructure concerns
- ✅ Always generated - consistent pattern across all aggregates
- ✅ No breaking changes to existing Factory APIs

This ensures the solution scales to production workloads with thousands (or millions) of aggregate instances while providing a developer-friendly API.
