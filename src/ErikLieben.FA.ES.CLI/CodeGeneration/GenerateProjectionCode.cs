using System.Text;
using ErikLieben.FA.ES.CLI.Analyze.Helpers;
using ErikLieben.FA.ES.CLI.Configuration;
using ErikLieben.FA.ES.CLI.Model;
using ErikLieben.FA.ES.Projections;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Formatting;
using Spectre.Console;

namespace ErikLieben.FA.ES.CLI.CodeGeneration;

public class GenerateProjectionCode
{
    private readonly SolutionDefinition solution;
    private readonly Config config;
    private readonly string solutionPath;

    public GenerateProjectionCode(SolutionDefinition solution, Config config, string solutionPath)
    {
        this.solution = solution;
        this.config = config;
        this.solutionPath = solutionPath;
    }

    public async Task Generate()
    {
        foreach (var project in solution.Projects.Where(p => !p.Name.StartsWith("ErikLieben.FA.ES")))
        {
            foreach (var projection in project.Projections)
            {
                AnsiConsole.MarkupLine($"Generating supporting partial class for: [yellow]{projection.Name}[/]");
                var currentFile = projection.FileLocations.FirstOrDefault();
                if (currentFile is null || currentFile.ToLowerInvariant().Contains(".generated"))
                {
                    continue;
                }

                var rel = (projection.FileLocations.FirstOrDefault() ?? string.Empty).Replace('\\', '/');
                var relGen = rel.EndsWith(".cs", StringComparison.OrdinalIgnoreCase)
                    ? rel.Substring(0, rel.Length - 3) + ".Generated.cs"
                    : rel + ".Generated.cs";
                var normalized = relGen.Replace('/', System.IO.Path.DirectorySeparatorChar)
                    .TrimStart(System.IO.Path.DirectorySeparatorChar, System.IO.Path.AltDirectorySeparatorChar);
                var path = System.IO.Path.Combine(solutionPath, normalized);
                AnsiConsole.MarkupLine($"Path: [blue]{path}[/]");
                await GenerateProjection(projection, path, config);
            }
        }
    }

    private async Task GenerateProjection(ProjectionDefinition projection, string? path, Config config)
    {
        var code = new StringBuilder();
        var usings = new List<string>
        {
            "System.Text.Json.Serialization",
            "ErikLieben.FA.ES",
            "ErikLieben.FA.ES.Projections",
            "ErikLieben.FA.ES.Documents",
            "System.Text.Json",
            "ErikLieben.FA.ES.VersionTokenParts"
        };

        foreach (var property in projection.Properties)
        {
            if (!usings.Contains(property.Namespace))
            {
                usings.Add(property.Namespace);
            }
        }

        var foldCode = new StringBuilder();
        var whenParameterDeclarations = new List<string>();

        foreach (var @event in projection.Events)
        {
            GenerateWhenMethods(@event, usings, whenParameterDeclarations, foldCode);
        }

        var serializableCode = new StringBuilder();
        var propertyTypes = new List<string>();

        // HACK
        // propertyTypes.Add("System.String");
        // propertyTypes.Add("System.Guid");

        var newJsonSerializableCode = new StringBuilder();
        foreach (var usedEvent in projection.Events)
        {

            newJsonSerializableCode.AppendLine("// <auto-generated />");
            if (usedEvent.Properties.Any(p => p.Type.EndsWith("Identifier")))
            {
                newJsonSerializableCode.AppendLine($"[JsonSerializable(typeof(System.Guid))]");
            }
            serializableCode.AppendLine($"[JsonSerializable(typeof({usedEvent.TypeName}))]");
            foreach (var property in usedEvent.Properties)
            {
                var fullTypeDef = property.Namespace + "." + property.Type;

                if (property.IsGeneric)
                {
                    fullTypeDef += "<";
                    foreach (var generic in property.GenericTypes)
                    {
                        fullTypeDef += generic.Namespace + "." + generic.Name;
                        if (property.GenericTypes.Last() != generic)
                        {
                            fullTypeDef += ",";
                        }
                    }
                    fullTypeDef += ">";
                }

                if (!propertyTypes.Contains(fullTypeDef))
                {
                    propertyTypes.Add(fullTypeDef);
                }

                newJsonSerializableCode.AppendLine($"[JsonSerializable(typeof({fullTypeDef}))]");
            }

            newJsonSerializableCode.AppendLine($"[JsonSerializable(typeof({@usedEvent.TypeName}))]");
            newJsonSerializableCode.AppendLine(
                "internal partial class " + usedEvent.TypeName + "JsonSerializerContext : JsonSerializerContext { }");
            newJsonSerializableCode.AppendLine("");
        }

        // foreach (var propertyType in propertyTypes)
        // {
        //     serializableCode.AppendLine($"[JsonSerializable(typeof({propertyType}))]");
        // }


        serializableCode.AppendLine($"[JsonSerializable(typeof({projection.Name}))]");

        var propertyCode = new StringBuilder();
        var propertySnapshotCode = new StringBuilder();
        // TODO: var propertyCopyCode = new StringBuilder();
        foreach (var property in projection.Properties)
        {
            string Inner(PropertyGenericTypeDefinition prop)
            {
                var type = prop.Namespace + "." + prop.Name;
                if (prop.GenericTypes.Count != 0)
                {
                    type += "<";
                    foreach (var generic in prop.GenericTypes)
                    {
                        // var x = !string.IsNullOrWhiteSpace(prop.Namespace) ? prop.Namespace + "." : string.Empty;
                        if (prop.GenericTypes.Count != 0)
                        {
                            type += Inner(prop.GenericTypes.First());
                        }
                        else
                        {
                            type += generic.Namespace + "." + generic.Name;
                        }

                        // type += x + generic.Name;
                        if (prop.GenericTypes.Last() != generic)
                        {
                            type += ",";
                        }
                    }
                    type += ">";
                }
                return type;
            }

            var type = property.Type;
            if (property.IsGeneric)
            {

                type += "<";
                foreach (var generic in property.GenericTypes)
                {
                    type += Inner(generic);
                    if (property.GenericTypes.Last() != generic)
                    {
                        type += ",";
                    }
                }
                type += ">";
            }

            if (property.Name != "WhenParameterValueFactories")
            {
                // TODO: propertyCopyCode.AppendLine($"this.{property.Name} = obj.{property.Name};");
                propertySnapshotCode.AppendLine($"public {type}{(property.IsNullable ? "?" : string.Empty)} {property.Name} {{get; init; }}");
            }

            if (property.Name != "Checkpoint" && projection.Name != "CheckpointFingerprint" && property.Name != "WhenParameterValueFactories")
            {
                propertyCode.AppendLine($"public {type}{(property.IsNullable ? "?" : string.Empty)} {property.Name} {{get;}}");
            }
        }

        string jsonBlobFactoryCode = string.Empty;
        if (projection.BlobProjection != null)
        {
            jsonBlobFactoryCode = $$"""
                                     public class {{projection.Name}}Factory(
                                         IAzureClientFactory<BlobServiceClient> blobServiceClientFactory,
                                         IObjectDocumentFactory objectDocumentFactory,
                                         IEventStreamFactory eventStreamFactory)
                                         : BlobProjectionFactory<{{projection.Name}}>(
                                             blobServiceClientFactory, 
                                             "{{projection.BlobProjection.Connection}}",
                                             "{{projection.BlobProjection.Container}}")
                                     {
                                         protected override bool HasExternalCheckpoint => {{projection.ExternalCheckpoint.ToString().ToLowerInvariant()}};
                                         
                                         protected override {{projection.Name}} New()
                                         {
                                             return new {{projection.Name}}(objectDocumentFactory, eventStreamFactory);
                                         }
                                     }
                                    """;
            usings.Add("ErikLieben.FA.ES.AzureStorage.Blob");
            usings.Add("Microsoft.Extensions.Azure");
            usings.Add("Azure.Storage.Blobs");
        }

        var checkpointJsonAnnotation = projection.ExternalCheckpoint ? "[JsonIgnore]" : "[JsonPropertyName(\"$checkpoint\")]";



        var whenParameterValueBindingCode = string.Empty;
        if (whenParameterDeclarations.Any())
        {
            whenParameterValueBindingCode = whenParameterDeclarations.Aggregate((x, y) => x + "," + y + Environment.NewLine);
        }

        var postWhenStringBuilder = new StringBuilder();
        if (projection.PostWhen != null)
        {
            postWhenStringBuilder.Append($"PostWhen(");

            foreach (var parameter in projection.PostWhen.Parameters)
            {
                switch (parameter.Type)
                {
                    case "IObjectDocument":
                        postWhenStringBuilder.Append("document");
                        break;
                    case "IEvent":
                        postWhenStringBuilder.Append("JsonEvent.ToEvent(@event, @event.EventType)");
                        break;
                }

                if (parameter != projection.PostWhen.Parameters.Last())
                {
                    postWhenStringBuilder.Append(", ");
                }
            }
            postWhenStringBuilder.Append(");");
        }

        var postWhenAllDummyCode = new StringBuilder();
        if (!projection.HasPostWhenAllMethod)
        {
            usings.Add("System.CodeDom.Compiler");
            postWhenAllDummyCode.Append($"[GeneratedCode(\"ErikLieben.FA.ES\", \"{solution.Generator?.Version}\")]\n");
            postWhenAllDummyCode.Append("protected override Task PostWhenAll(IObjectDocument document) { return Task.CompletedTask; }");
        }

        var xx = $$$"""
                    #nullable enable
                    public override {{{(projection.Events.Any(e => e.ActivationAwaitRequired) ? "async " : string.Empty)}}} Task Fold<T>(IEvent @event, IObjectDocument document, T? data = default(T?), IExecutionContext? parentContext = null) where T : class {
                       
                       
                       
                       switch (@event.EventType)
                       {
                           {{{foldCode}}}
                       }
                       
                       {{{postWhenStringBuilder}}}
                       
                       return {{{(projection.Events.Any(e => e.ActivationAwaitRequired) ? "" : "Task.CompletedTask")}}};
                    }
                    
                    {{{postWhenAllDummyCode}}}
                    #nullable restore
                    """;

        var yy= $$"""
                  public override {{(projection.Events.Any(e => e.ActivationAwaitRequired) ? "async " : string.Empty)}}Task Fold(IEvent @event, IObjectDocument document)
                  {
                      switch (@event.EventType)
                      {
                          {{foldCode}}
                      }
                      
                      {{postWhenStringBuilder}}
                      
                      return {{(projection.Events.Any(e => e.ActivationAwaitRequired) ? "" : "Task.CompletedTask")}};
                  }
                  
                  {{postWhenAllDummyCode}}
                 """;

        //

        //===
        var ctorCode = new StringBuilder();

        // Get all constructors and properties
        var ctors = projection.Constructors;
        var properties = projection.Properties;

        // Define special dependencies we need to supply ourselves
        var specialDependencies = new[] { "IObjectDocumentFactory", "IEventStreamFactory" };

        // Evaluate each constructor with a score and additional info
        var rankedConstructors = ctors
            .Select(ctor =>
            {
                // Check for required special dependencies
                bool hasAllSpecialDeps = specialDependencies.All(dep =>
                    ctor.Parameters.Any(p => p.Type == dep));

                // Regular parameters (excluding special dependencies)
                var regularParams = ctor.Parameters
                    .Where(p => !specialDependencies.Contains(p.Type))
                    .ToList();

                // Count how many regular parameters match properties
                int matchedParamCount = regularParams.Count(param =>
                    properties.Any(prop =>
                        prop.Type == param.Type &&
                        (string.Equals(prop.Name, param.Name, StringComparison.OrdinalIgnoreCase) ||
                         string.Equals(prop.Name, "_" + param.Name, StringComparison.OrdinalIgnoreCase))));

                // Calculate match percentage for regular parameters
                double matchPercentage = regularParams.Count > 0
                    ? (double)matchedParamCount / regularParams.Count
                    : 0;

                return new {
                    Constructor = ctor,
                    HasRequiredDeps = hasAllSpecialDeps,
                    MatchedCount = matchedParamCount,
                    TotalRegularParams = regularParams.Count,
                    MatchPercentage = matchPercentage
                };
            })
            // Filter out constructors missing required dependencies
            .Where(result => result.HasRequiredDeps)
            // Order by match percentage (highest first), then by total parameter count (prefer more params)
            .OrderByDescending(result => result.MatchPercentage)
            .ThenByDescending(result => result.TotalRegularParams)
            .ToList();

        // Get the best matching constructor if any
        var bestMatch = rankedConstructors.FirstOrDefault();

        if (bestMatch != null)
        {
            var constructor = bestMatch.Constructor;

            foreach (var parameter in constructor.Parameters)
            {
                if (parameter.Type is "IObjectDocumentFactory" or "IEventStreamFactory")
                {
                    switch (parameter.Type)
                    {
                        case "IObjectDocumentFactory":
                            ctorCode.Append("documentFactory");
                            break;
                        case "IEventStreamFactory":
                            ctorCode.Append("eventStreamFactory");
                            break;
                    }
                }
                else
                {
                    var name = projection.Properties.FirstOrDefault(p => p.Name.Equals(parameter.Name, StringComparison.InvariantCultureIgnoreCase))?.Name;
                    if (name is null)
                    {
                        continue;
                    }
                    ctorCode.Append("obj." + name);
                }

                if (parameter != constructor.Parameters.Last())
                {
                    ctorCode.Append(", ");
                }
            }
        }


        foreach (var namespaceName in usings.Distinct().Order())
        {
            code.AppendLine($"using {namespaceName};");
        }

        code.AppendLine("");
        code.AppendLine($$"""

                          namespace {{projection.Namespace}};

                          // <auto-generated />
                          public partial class {{projection.Name}} : I{{projection.Name}} {
                          
                              public {{projection.Name}}() : base() {
                              }
                              
                              public {{projection.Name}}(IObjectDocumentFactory documentFactory, IEventStreamFactory eventStreamFactory) 
                                : base(documentFactory,eventStreamFactory) {
                              }
                          
                              {{xx}}
                              
                              protected override Dictionary<string, IProjectionWhenParameterValueFactory> WhenParameterValueFactories { get; } =
                                    new Dictionary<string, IProjectionWhenParameterValueFactory>(){
                                        {{ whenParameterValueBindingCode }}
                                    };
                              
                              public static {{projection.Name}}? LoadFromJson(string json, IObjectDocumentFactory documentFactory, IEventStreamFactory eventStreamFactory)
                              {
                                var obj = JsonSerializer.Deserialize(json, {{projection.Name}}JsonSerializerContext.Default.{{projection.Name}});
                                if (obj is null) {
                                    return null;
                                }
                                return new {{projection.Name}}({{ctorCode}});
                              }
                              
                              
                              public override string ToJson()
                              {
                                return JsonSerializer.Serialize(this, {{projection.Name}}JsonSerializerContext.Default.{{projection.Name}});
                              } 
                              
                              {{checkpointJsonAnnotation}}
                              public override Checkpoint Checkpoint { get; set; } = [];
                          }
                          
                          {{jsonBlobFactoryCode}}

                          #nullable enable
                          // <auto-generated />
                          public interface I{{projection.Name}} {
                                {{propertyCode}}
                          }
                          #nullable restore

                          {{serializableCode}}
                          // <auto-generated />
                          internal partial class {{projection.Name}}JsonSerializerContext : JsonSerializerContext
                          {
                          }

                          """);

        var directory = Path.GetDirectoryName(path!);
        if (!string.IsNullOrEmpty(directory))
        {
            Directory.CreateDirectory(directory);
        }
        Directory.CreateDirectory(System.IO.Path.GetDirectoryName(path!)!);
        await File.WriteAllTextAsync(path!, FormatCode(code.ToString()));



    //     [JsonPropertyName("$checkpoint")]
    // public abstract Dictionary<ObjectIdentifier, VersionIdentifier> Checkpoint { get; set; }
    //
    // [JsonPropertyName("$checkpointHash")]
    // [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    // public string? CheckpointHash { get; set; }

    }

    private static void GenerateWhenMethods(

        ProjectionEventDefinition @event,
        List<string> usings,
        List<string> whenParameterDeclarations,
        StringBuilder foldCode)
    {
        if (@event.ActivationType != "When")
        {
            return;
        }

        if (!usings.Contains(@event.Namespace))
        {
            usings.Add(@event.Namespace);
        }

        var fistParameter = @event.Parameters.FirstOrDefault();
        if (fistParameter is null)
        {
            return;
        }

        string awaitCode = @event.ActivationAwaitRequired ? "await " : string.Empty;
        foldCode.Append($$"""
                          case "{{@event.EventName}}":
                            {{awaitCode}} When(
                          """);

        if (fistParameter.Type == @event.TypeName && fistParameter.Type != "IEvent")
        {
            foldCode.Append(
                $"JsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName}).Data()");
        }
        else if (fistParameter.Type == "IEvent")
        {
            foldCode.Append(
                $"JsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName})");
        }

        if (@event.Parameters.Count > 1)
        {
            foldCode.Append(", ");
        }

        foreach (var parameterFactory in @event.WhenParameterValueFactories)
        {
            var toAdd = $"{{\"{parameterFactory.ForType.Type}\", new {parameterFactory.Type.Type}()}}";
            if (!whenParameterDeclarations.Contains(toAdd))
            {
                whenParameterDeclarations.Add(toAdd);
            }

            if (!usings.Contains(parameterFactory.ForType.Namespace))
            {
                usings.Add(parameterFactory.ForType.Namespace);
            }
        }

        var whenLookups = new Dictionary<string, string>();
        foreach (var parameterDeclaration in @event.WhenParameterDeclarations)
        {
            switch (parameterDeclaration.Type)
            {
                case "IExecutionContextWithData":
                    var lastGenericType = parameterDeclaration.GenericArguments.LastOrDefault()?.Type ?? "object";
                    whenLookups.Add(
                        parameterDeclaration.Type,
                        Environment.NewLine +
                        $"\t\tnew ExecutionContext<{@event.TypeName},{lastGenericType}>({
                            Environment.NewLine
                        }\t\t\tJsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName}),{
                            Environment.NewLine
                        }\t\t\tdocument,{
                            Environment.NewLine
                        }\t\t\tdata as {lastGenericType},{
                            Environment.NewLine
                        }\t\t\tparentContext as IExecutionContextWithData<{lastGenericType}>)"
                    );
                    break;
                case "IExecutionContext":
                case "IExecutionContextWithEvent":
                    whenLookups.Add(
                        parameterDeclaration.Type,
                        Environment.NewLine +
                        $"\t\tnew ExecutionContext<{@event.TypeName},object>({
                            Environment.NewLine
                        }\t\t\tJsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName}),{
                            Environment.NewLine
                        }\t\t\tdocument,{
                            Environment.NewLine
                        }\t\t\tnull!,{
                            Environment.NewLine
                        }\t\t\tparentContext as IExecutionContext<{@event.TypeName},object>)");
                    break;
                default:
                    usings.Add(parameterDeclaration.Namespace);
                    whenLookups.Add(parameterDeclaration.Type,
                        $"GetWhenParameterValue<{parameterDeclaration.Type}, {@event.TypeName}>({Environment.NewLine}\t\t\t\"{parameterDeclaration.Namespace}.{parameterDeclaration.Type}\",{Environment.NewLine}\t\t\tdocument, @event)!");
                    break;
            }
        }

        foreach (var parameter in @event.Parameters.Skip(1))
        {
            if (whenLookups.TryGetValue(parameter.Type, out var lookupCode))
            {
                foldCode.Append(lookupCode);
            }
            else switch (parameter.Type)
            {
                case "IEvent":
                    foldCode.Append(
                        $"JsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName})");
                    break;
                case "IObjectDocument":
                    foldCode.Append($"document");
                    break;
                default:
                {
                    if (parameter.Type.StartsWith("IExecutionContext"))
                    {
                        foldCode.Append($"parentContext");
                    }

                    break;
                }
            }

            if (@event.Parameters.Last() != parameter)
            {
                foldCode.Append(", ");
            }
        }

        foldCode.Append("""
                        );
                        break;
                        """);
    }

//     private static void GenerateWhenMethods22(
//         ProjectionEventDefinition @event,
//         List<string> usings,
//         List<string> whenParameterDeclarations,
//         StringBuilder foldCode)
//     {
//         if (@event.ActivationType == "When")
//         {
//             // When
//             if (!usings.Contains(@event.Namespace))
//             {
//                 usings.Add(@event.Namespace);
//             }
//
//             // TODO: we would first require the params as well
//             foreach (var parameterFactory in @event.WhenParameterValueFactories)
//             {
//                 var toAdd = $"{{\"{parameterFactory.ForType.Type}\", new {parameterFactory.Type.Type}()}}";
//                 if (!whenParameterDeclarations.Contains(toAdd))
//                 {
//                     whenParameterDeclarations.Add(toAdd);
//                 }
//
//                 if (!usings.Contains(parameterFactory.ForType.Namespace))
//                 {
//                     usings.Add(parameterFactory.ForType.Namespace);
//                 }
//             }
//
//             if (@event.WhenParameterDeclarations.Count == 0)
//             {
//
//                 // do what we did before...
//                 foldCode.AppendLine($$"""
//                                       case "{{@event.EventName}}":
//                                           {{(@event.ActivationAwaitRequired ? "await " : string.Empty)}}When({{Environment.NewLine + "\t\t"}}JsonEvent.To(@event, {{@event.TypeName}}JsonSerializerContext.Default.{{@event.TypeName}}));
//                                       break;
//                                       """);
//             }
//             else
//             {
//
//                 if (@event.WhenParameterDeclarations.Count == 1 &&
//                     @event.WhenParameterDeclarations.First().Type == @event.TypeName)
//                 {
//                     // do what we did before...
//                     foldCode.AppendLine($$"""
//                                           case "{{@event.EventName}}":
//                                               {{(@event.ActivationAwaitRequired ? "await " : string.Empty)}}When({{Environment.NewLine + "\t\t"}}JsonEvent.To(@event, {{@event.TypeName}}JsonSerializerContext.Default.{{@event.TypeName}}));
//                                           break;
//                                           """);
//                 }
//                 else
//                 {
//                     // case "FeatureFlag.Enabled":
//                     //     var identifier = GetWhenParameterValue<FooIdentifier, FeatureFlagEnabled>("DemoApp.Projections.FooIdentifier", document, @event);
//                     //     When(JsonEvent.To(@event, FeatureFlagEnabledJsonSerializerContext.Default.FeatureFlagEnabled), identifier);
//                     //     break;
//
//
//                     string codeee = string.Empty;
//                     foreach (var parameterDeclaration in @event.WhenParameterDeclarations)
//                     {
//                         if (@event.TypeName == parameterDeclaration.Type)
//                         {
//                             continue;
//                         }
//
//                         if (parameterDeclaration.Type.StartsWith("IExecutionContextWithData"))
//                         {
//                             var x = parameterDeclaration.GenericArguments.LastOrDefault();
//                             if (x is not null)
//                             {
//                                 codeee += Environment.NewLine +
//                                           $"\t\tnew ExecutionContext<{@event.TypeName},{x.Type}>({
//                                               Environment.NewLine
//                                           }\t\t\tJsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName}),{
//                                               Environment.NewLine
//                                           }\t\t\tdocument,{
//                                               Environment.NewLine
//                                           }\t\t\tdata as {x.Type},{
//                                               Environment.NewLine
//                                           }\t\t\tparentContext as IExecutionContextWithData<{x.Type}>)";
//                             }
//                         }
//                         else if (parameterDeclaration.Type.StartsWith("IExecutionContextWithEvent"))
//                         {
//                             codeee += Environment.NewLine +
//                                       $"\t\tnew ExecutionContext<{@event.TypeName},object>({
//                                           Environment.NewLine
//                                       }\t\t\tJsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName}),{
//                                           Environment.NewLine
//                                       }\t\t\tdocument,{
//                                           Environment.NewLine
//                                       }\t\t\tnull!,{
//                                           Environment.NewLine
//                                       }\t\t\tparentContext as IExecutionContext<{@event.TypeName},object>)";
//                         }
//                         else if (parameterDeclaration.Type.StartsWith("IExecutionContext"))
//                         {
//                             codeee += Environment.NewLine +
//                                       $"\t\tnew ExecutionContext<{@event.TypeName},object>({
//                                           Environment.NewLine
//                                       }\t\t\tJsonEvent.ToEvent(@event, {@event.TypeName}JsonSerializerContext.Default.{@event.TypeName}),{
//                                           Environment.NewLine
//                                       }\t\t\tdocument,{
//                                           Environment.NewLine
//                                       }\t\t\tnull!,{
//                                           Environment.NewLine
//                                       }\t\t\tparentContext as IExecutionContext<{@event.TypeName},object>)";
//                         }
//                         else
//                         {
//                             codeee += Environment.NewLine +
//                                       $"\t\tGetWhenParameterValue<{parameterDeclaration.Type}, {@event.TypeName}>({Environment.NewLine}\t\t\t\"{parameterDeclaration.Namespace}.{parameterDeclaration.Type}\",{Environment.NewLine}\t\t\tdocument, @event)!";
//                         }
//
//                         if (parameterDeclaration != @event.WhenParameterDeclarations.Last())
//                         {
//                             codeee += ", ";
//                         }
//                     }
//
//                     foldCode.AppendLine($$"""
//
//                                           case "{{@event.EventName}}":
//                                               {{(@event.ActivationAwaitRequired ? "await " : string.Empty)}}When(JsonEvent.To(@event, {{@event.TypeName}}JsonSerializerContext.Default.{{@event.TypeName}}), {{codeee}});
//                                           break;
//                                           """);
//                 }
//             }
//
//         }
//     }

    private static string FormatCode(string code, CancellationToken cancelToken = default)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(code, cancellationToken: cancelToken);
        var syntaxNode = syntaxTree.GetRoot(cancelToken);

        using var workspace = new AdhocWorkspace();
        var options = workspace.Options
            .WithChangedOption(FormattingOptions.SmartIndent, LanguageNames.CSharp,
                FormattingOptions.IndentStyle.Smart);

        var formattedNode = Formatter.Format(syntaxNode, workspace, options, cancellationToken: cancelToken);
        return formattedNode.ToFullString();
    }

}
