using ErikLieben.FA.ES.Observability;
using ErikLieben.FA.ES.Snapshots;

namespace ErikLieben.FA.ES.Processors;

/// <summary>
/// Provides a base class for aggregates that fold events from an event stream to build up state through event sourcing.
/// </summary>
public abstract class Aggregate : IBase, ISnapshotTracker
{

    // Snapshot tracking fields
    private int _eventsSinceLastSnapshot;
    private int _totalEventsProcessed;
    private int? _lastSnapshotVersion;

    /// <summary>
    /// Gets the event stream associated with this aggregate.
    /// </summary>
    protected IEventStream Stream { get; private set; }

    /// <summary>
    /// Gets the event stream for external validation purposes.
    /// Use this for checkpoint validation in idempotency patterns.
    /// </summary>
    public IEventStream EventStream => Stream;

    /// <summary>
    /// Initializes a new instance of the <see cref="Aggregate"/> class with the specified event stream.
    /// </summary>
    /// <param name="stream">The event stream to fold events from.</param>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="stream"/> is null.</exception>
    protected Aggregate(IEventStream stream)
    {
        ArgumentNullException.ThrowIfNull(stream);

        Stream = stream;
#pragma warning disable S1699 // Content of method is generated using roslyn
        GeneratedSetup();
#pragma warning restore S1699
    }

    /// <summary>
    /// Folds a single event into this aggregate's state. Override this method in derived classes to handle specific event types.
    /// </summary>
    /// <param name="event">The event to fold into the aggregate state.</param>
    public virtual void Fold(IEvent @event) { }

    /// <summary>
    /// Folds all events from the stream into this aggregate's state, optionally starting from the latest snapshot.
    /// </summary>
    /// <returns>A task representing the asynchronous fold operation.</returns>
    public async Task Fold()
    {
        using var activity = FaesInstrumentation.Core.StartActivity("Aggregate.Fold");
        if (activity?.IsAllDataRequested == true)
        {
            activity.SetTag(FaesSemanticConventions.StreamId, Stream.StreamIdentifier);
            activity.SetTag(FaesSemanticConventions.ObjectName, Stream.Document.ObjectName);
            activity.SetTag(FaesSemanticConventions.ObjectId, Stream.Document.ObjectId);
        }

        if (Stream.Settings.ManualFolding)
        {
            return;
        }

        IReadOnlyCollection<IEvent> events = [];
        if (Stream.Document.Active.HasSnapShots())
        {
            var lastSnapshot = Stream.Document.Active.SnapShots.LastOrDefault();
            if (lastSnapshot != null)
            {
                var snapshot = await Stream.GetSnapShot(lastSnapshot.UntilVersion);
                if (snapshot != null)
                {
                    ProcessSnapshot(snapshot);
                }
                events = await Stream.ReadAsync(lastSnapshot.UntilVersion + 1);
            }
        }
        else
        {
            events = await Stream.ReadAsync();
        }

        activity?.SetTag(FaesSemanticConventions.EventsFolded, events.Count);

        foreach (var e in events)
        {
            Fold(e);
        }
    }

    /// <summary>
    /// Performs any necessary setup generated by Roslyn source generators. Override this method in derived classes when using code generation.
    /// </summary>
    protected virtual void GeneratedSetup() { }

    /// <summary>
    /// Processes a snapshot to restore aggregate state. Override this method in derived classes to handle snapshot restoration.
    /// </summary>
    /// <param name="snapshot">The snapshot object containing the saved aggregate state.</param>
    public virtual void ProcessSnapshot(object snapshot) { }

    #region ISnapshotTracker Implementation

    /// <inheritdoc />
    public int EventsSinceLastSnapshot => _eventsSinceLastSnapshot;

    /// <inheritdoc />
    public int TotalEventsProcessed => _totalEventsProcessed;

    /// <inheritdoc />
    public int? LastSnapshotVersion => _lastSnapshotVersion;

    /// <inheritdoc />
    public void RecordEventsAppended(int count)
    {
        _eventsSinceLastSnapshot += count;
        _totalEventsProcessed += count;
    }

    /// <inheritdoc />
    public void RecordEventsFolded(int count)
    {
        _totalEventsProcessed += count;
        _eventsSinceLastSnapshot += count;
    }

    /// <inheritdoc />
    public void RecordSnapshotCreated(int version)
    {
        _lastSnapshotVersion = version;
        _eventsSinceLastSnapshot = 0;
    }

    /// <inheritdoc />
    public void ResetFromSnapshot(int snapshotVersion)
    {
        _lastSnapshotVersion = snapshotVersion;
        _eventsSinceLastSnapshot = 0;
        _totalEventsProcessed = snapshotVersion; // Approximate - actual events up to snapshot
    }

    #endregion
}