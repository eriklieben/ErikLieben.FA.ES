using System.Diagnostics;

namespace ErikLieben.FA.ES.Processors;

/// <summary>
/// Provides a base class for aggregates that fold events from an event stream to build up state through event sourcing.
/// </summary>
public abstract class Aggregate : IBase
{
     private static readonly ActivitySource ActivitySource = new("ErikLieben.FA.ES");

    /// <summary>
    /// Gets the event stream associated with this aggregate.
    /// </summary>
    protected IEventStream Stream { get; private set; }

    /// <summary>
    /// Initializes a new instance of the <see cref="Aggregate"/> class with the specified event stream.
    /// </summary>
    /// <param name="stream">The event stream to fold events from.</param>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="stream"/> is null.</exception>
    protected Aggregate(IEventStream stream)
    {
        ArgumentNullException.ThrowIfNull(stream);

        Stream = stream;
#pragma warning disable S1699 // Content of method is generated using roslyn
        GeneratedSetup();
#pragma warning restore S1699
    }

    /// <summary>
    /// Folds a single event into this aggregate's state. Override this method in derived classes to handle specific event types.
    /// </summary>
    /// <param name="event">The event to fold into the aggregate state.</param>
    public virtual void Fold(IEvent @event) { }

    /// <summary>
    /// Folds all events from the stream into this aggregate's state, optionally starting from the latest snapshot.
    /// </summary>
    /// <returns>A task representing the asynchronous fold operation.</returns>
    public async Task Fold()
    {

        using var activity = ActivitySource.StartActivity($"Aggregate.{nameof(Fold)}");

        if (Stream.Settings.ManualFolding)
        {
            return;
        }

        IReadOnlyCollection<IEvent> events = [];
        if (Stream.Document.Active.HasSnapShots())
        {
            var lastSnapshot = Stream.Document.Active.SnapShots.LastOrDefault();
            if (lastSnapshot != null)
            {
                var snapshot = await Stream.GetSnapShot(lastSnapshot.UntilVersion);
                if (snapshot != null)
                {
                    ProcessSnapshot(snapshot);
                }
                events = await Stream.ReadAsync(lastSnapshot.UntilVersion + 1);
            }
        }
        else
        {
            events = await Stream.ReadAsync();
        }

        var eventsToFold = events.ToList();
        activity?.AddTag("EventsToFold", eventsToFold.Count.ToString());

        eventsToFold.ForEach(Fold);
    }

    /// <summary>
    /// Performs any necessary setup generated by Roslyn source generators. Override this method in derived classes when using code generation.
    /// </summary>
    protected virtual void GeneratedSetup() { }

    /// <summary>
    /// Processes a snapshot to restore aggregate state. Override this method in derived classes to handle snapshot restoration.
    /// </summary>
    /// <param name="snapshot">The snapshot object containing the saved aggregate state.</param>
    public virtual void ProcessSnapshot(object snapshot) { }

}